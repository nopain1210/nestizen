// This file is generated by @nestizen/graphql-plugin. DO NOT MANUALLY EDIT!
/* eslint-disable */
import {
  registerEnumType,
  Field,
  ObjectType,
  Int,
  Float,
  InputType,
  ArgsType,
} from '@nestjs/graphql';
import {
  GraphQLJSON,
  GraphQLHexadecimal,
  GraphQLByte,
  GraphQLBigInt,
} from 'graphql-scalars';

/** UserRole Documentation */
export enum UserRole {
  /** UserRole USER */
  USER = 'USER',
  /** UserRole ADMIN */
  ADMIN = 'ADMIN',
  /** UserRole MODERATOR */
  MODERATOR = 'MODERATOR',
}

registerEnumType(UserRole, {
  name: 'UserRole',
  description: 'UserRole Documentation',
  valuesMap: {
    USER: { description: 'UserRole USER' },
    ADMIN: { description: 'UserRole ADMIN' },
    MODERATOR: { description: 'UserRole MODERATOR' },
  },
});

export enum PostKind {
  BLOG = 'BLOG',
  ADVERT = 'ADVERT',
}

registerEnumType(PostKind, {
  name: 'PostKind',
  valuesMap: { BLOG: {}, ADVERT: {} },
});

export enum UserScalarFieldEnum {
  id = 'id',
  createdAt = 'createdAt',
  updatedAt = 'updatedAt',
  email = 'email',
  name = 'name',
  role = 'role',
  parentId = 'parentId',
  mappedField = 'mappedField',
}

registerEnumType(UserScalarFieldEnum, {
  name: 'UserScalarFieldEnum',
  valuesMap: {},
});

export enum ProfileScalarFieldEnum {
  id = 'id',
  createdAt = 'createdAt',
  updatedAt = 'updatedAt',
  bio = 'bio',
  userId = 'userId',
}

registerEnumType(ProfileScalarFieldEnum, {
  name: 'ProfileScalarFieldEnum',
  valuesMap: {},
});

export enum PostScalarFieldEnum {
  id = 'id',
  createdAt = 'createdAt',
  updatedAt = 'updatedAt',
  title = 'title',
  content = 'content',
  published = 'published',
  authorId = 'authorId',
  anotherAuthorId = 'anotherAuthorId',
  postKind = 'postKind',
}

registerEnumType(PostScalarFieldEnum, {
  name: 'PostScalarFieldEnum',
  valuesMap: {},
});

export enum TagScalarFieldEnum {
  key = 'key',
}

registerEnumType(TagScalarFieldEnum, {
  name: 'TagScalarFieldEnum',
  valuesMap: {},
});

export enum CategoryScalarFieldEnum {
  id = 'id',
  createdAt = 'createdAt',
  updatedAt = 'updatedAt',
  name = 'name',
}

registerEnumType(CategoryScalarFieldEnum, {
  name: 'CategoryScalarFieldEnum',
  valuesMap: {},
});

export enum CategoryMetadataScalarFieldEnum {
  id = 'id',
  createdAt = 'createdAt',
  updatedAt = 'updatedAt',
  categoryId = 'categoryId',
  metadata = 'metadata',
}

registerEnumType(CategoryMetadataScalarFieldEnum, {
  name: 'CategoryMetadataScalarFieldEnum',
  valuesMap: {},
});

export enum MiscModelScalarFieldEnum {
  id = 'id',
  createdAt = 'createdAt',
  updatedAt = 'updatedAt',
  name = 'name',
  jsonField = 'jsonField',
  jsonList = 'jsonList',
  stringList = 'stringList',
  decimalField = 'decimalField',
  decimalList = 'decimalList',
  floatField = 'floatField',
  bytesField = 'bytesField',
  bytesList = 'bytesList',
  bigIntField = 'bigIntField',
  bigIntList = 'bigIntList',
  dateTimeField = 'dateTimeField',
  dateTimeList = 'dateTimeList',
}

registerEnumType(MiscModelScalarFieldEnum, {
  name: 'MiscModelScalarFieldEnum',
  valuesMap: {},
});

export enum HiddenModelScalarFieldEnum {
  id = 'id',
  createdAt = 'createdAt',
  updatedAt = 'updatedAt',
  data = 'data',
}

registerEnumType(HiddenModelScalarFieldEnum, {
  name: 'HiddenModelScalarFieldEnum',
  valuesMap: {},
});

export enum SortOrder {
  asc = 'asc',
  desc = 'desc',
}

registerEnumType(SortOrder, { name: 'SortOrder', valuesMap: {} });

export enum QueryMode {
  'default' = 'default',
  insensitive = 'insensitive',
}

registerEnumType(QueryMode, { name: 'QueryMode', valuesMap: {} });

export enum NullsOrder {
  first = 'first',
  last = 'last',
}

registerEnumType(NullsOrder, { name: 'NullsOrder', valuesMap: {} });

@ObjectType({})
export class AggregateUser {
  @Field(() => UserCountAggregateOutputType, { nullable: true })
  _count: UserCountAggregateOutputType | null;
  @Field(() => UserAvgAggregateOutputType, { nullable: true })
  _avg: UserAvgAggregateOutputType | null;
  @Field(() => UserSumAggregateOutputType, { nullable: true })
  _sum: UserSumAggregateOutputType | null;
  @Field(() => UserMinAggregateOutputType, { nullable: true })
  _min: UserMinAggregateOutputType | null;
  @Field(() => UserMaxAggregateOutputType, { nullable: true })
  _max: UserMaxAggregateOutputType | null;
}

@ObjectType({})
export class UserGroupByOutputType {
  @Field(() => Int, { nullable: false })
  id: number;
  @Field(() => Date, { nullable: false })
  createdAt: Date;
  @Field(() => Date, { nullable: false })
  updatedAt: Date;
  @Field(() => String, { nullable: false })
  email: string;
  @Field(() => String, { nullable: true })
  name: string | null;
  @Field(() => UserRole, { nullable: false })
  role: UserRole;
  @Field(() => Int, { nullable: true })
  parentId: number | null;
  @Field(() => String, { nullable: false })
  mappedField: string;
  @Field(() => UserCountAggregateOutputType, { nullable: true })
  _count: UserCountAggregateOutputType | null;
  @Field(() => UserAvgAggregateOutputType, { nullable: true })
  _avg: UserAvgAggregateOutputType | null;
  @Field(() => UserSumAggregateOutputType, { nullable: true })
  _sum: UserSumAggregateOutputType | null;
  @Field(() => UserMinAggregateOutputType, { nullable: true })
  _min: UserMinAggregateOutputType | null;
  @Field(() => UserMaxAggregateOutputType, { nullable: true })
  _max: UserMaxAggregateOutputType | null;
}

@ObjectType({})
export class AggregateProfile {
  @Field(() => ProfileCountAggregateOutputType, { nullable: true })
  _count: ProfileCountAggregateOutputType | null;
  @Field(() => ProfileAvgAggregateOutputType, { nullable: true })
  _avg: ProfileAvgAggregateOutputType | null;
  @Field(() => ProfileSumAggregateOutputType, { nullable: true })
  _sum: ProfileSumAggregateOutputType | null;
  @Field(() => ProfileMinAggregateOutputType, { nullable: true })
  _min: ProfileMinAggregateOutputType | null;
  @Field(() => ProfileMaxAggregateOutputType, { nullable: true })
  _max: ProfileMaxAggregateOutputType | null;
}

@ObjectType({})
export class ProfileGroupByOutputType {
  @Field(() => Int, { nullable: false })
  id: number;
  @Field(() => Date, { nullable: false })
  createdAt: Date;
  @Field(() => Date, { nullable: false })
  updatedAt: Date;
  @Field(() => String, { nullable: true })
  bio: string | null;
  @Field(() => Int, { nullable: false })
  userId: number;
  @Field(() => ProfileCountAggregateOutputType, { nullable: true })
  _count: ProfileCountAggregateOutputType | null;
  @Field(() => ProfileAvgAggregateOutputType, { nullable: true })
  _avg: ProfileAvgAggregateOutputType | null;
  @Field(() => ProfileSumAggregateOutputType, { nullable: true })
  _sum: ProfileSumAggregateOutputType | null;
  @Field(() => ProfileMinAggregateOutputType, { nullable: true })
  _min: ProfileMinAggregateOutputType | null;
  @Field(() => ProfileMaxAggregateOutputType, { nullable: true })
  _max: ProfileMaxAggregateOutputType | null;
}

@ObjectType({})
export class AggregatePost {
  @Field(() => PostCountAggregateOutputType, { nullable: true })
  _count: PostCountAggregateOutputType | null;
  @Field(() => PostAvgAggregateOutputType, { nullable: true })
  _avg: PostAvgAggregateOutputType | null;
  @Field(() => PostSumAggregateOutputType, { nullable: true })
  _sum: PostSumAggregateOutputType | null;
  @Field(() => PostMinAggregateOutputType, { nullable: true })
  _min: PostMinAggregateOutputType | null;
  @Field(() => PostMaxAggregateOutputType, { nullable: true })
  _max: PostMaxAggregateOutputType | null;
}

@ObjectType({})
export class PostGroupByOutputType {
  @Field(() => Int, { nullable: false })
  id: number;
  @Field(() => Date, { nullable: false })
  createdAt: Date;
  @Field(() => Date, { nullable: false })
  updatedAt: Date;
  @Field(() => String, { nullable: false })
  title: string;
  @Field(() => String, { nullable: true })
  content: string | null;
  @Field(() => Boolean, { nullable: false })
  published: boolean;
  @Field(() => Int, { nullable: false })
  authorId: number;
  @Field(() => Int, { nullable: false })
  anotherAuthorId: number;
  @Field(() => PostKind, { nullable: false })
  postKind: PostKind;
  @Field(() => PostCountAggregateOutputType, { nullable: true })
  _count: PostCountAggregateOutputType | null;
  @Field(() => PostAvgAggregateOutputType, { nullable: true })
  _avg: PostAvgAggregateOutputType | null;
  @Field(() => PostSumAggregateOutputType, { nullable: true })
  _sum: PostSumAggregateOutputType | null;
  @Field(() => PostMinAggregateOutputType, { nullable: true })
  _min: PostMinAggregateOutputType | null;
  @Field(() => PostMaxAggregateOutputType, { nullable: true })
  _max: PostMaxAggregateOutputType | null;
}

@ObjectType({})
export class AggregateTag {
  @Field(() => TagCountAggregateOutputType, { nullable: true })
  _count: TagCountAggregateOutputType | null;
  @Field(() => TagMinAggregateOutputType, { nullable: true })
  _min: TagMinAggregateOutputType | null;
  @Field(() => TagMaxAggregateOutputType, { nullable: true })
  _max: TagMaxAggregateOutputType | null;
}

@ObjectType({})
export class TagGroupByOutputType {
  @Field(() => String, { nullable: false })
  key: string;
  @Field(() => TagCountAggregateOutputType, { nullable: true })
  _count: TagCountAggregateOutputType | null;
  @Field(() => TagMinAggregateOutputType, { nullable: true })
  _min: TagMinAggregateOutputType | null;
  @Field(() => TagMaxAggregateOutputType, { nullable: true })
  _max: TagMaxAggregateOutputType | null;
}

@ObjectType({})
export class AggregateCategory {
  @Field(() => CategoryCountAggregateOutputType, { nullable: true })
  _count: CategoryCountAggregateOutputType | null;
  @Field(() => CategoryAvgAggregateOutputType, { nullable: true })
  _avg: CategoryAvgAggregateOutputType | null;
  @Field(() => CategorySumAggregateOutputType, { nullable: true })
  _sum: CategorySumAggregateOutputType | null;
  @Field(() => CategoryMinAggregateOutputType, { nullable: true })
  _min: CategoryMinAggregateOutputType | null;
  @Field(() => CategoryMaxAggregateOutputType, { nullable: true })
  _max: CategoryMaxAggregateOutputType | null;
}

@ObjectType({})
export class CategoryGroupByOutputType {
  @Field(() => Int, { nullable: false })
  id: number;
  @Field(() => Date, { nullable: false })
  createdAt: Date;
  @Field(() => Date, { nullable: false })
  updatedAt: Date;
  @Field(() => String, { nullable: false })
  name: string;
  @Field(() => CategoryCountAggregateOutputType, { nullable: true })
  _count: CategoryCountAggregateOutputType | null;
  @Field(() => CategoryAvgAggregateOutputType, { nullable: true })
  _avg: CategoryAvgAggregateOutputType | null;
  @Field(() => CategorySumAggregateOutputType, { nullable: true })
  _sum: CategorySumAggregateOutputType | null;
  @Field(() => CategoryMinAggregateOutputType, { nullable: true })
  _min: CategoryMinAggregateOutputType | null;
  @Field(() => CategoryMaxAggregateOutputType, { nullable: true })
  _max: CategoryMaxAggregateOutputType | null;
}

@ObjectType({})
export class AggregateCategoryMetadata {
  @Field(() => CategoryMetadataCountAggregateOutputType, { nullable: true })
  _count: CategoryMetadataCountAggregateOutputType | null;
  @Field(() => CategoryMetadataAvgAggregateOutputType, { nullable: true })
  _avg: CategoryMetadataAvgAggregateOutputType | null;
  @Field(() => CategoryMetadataSumAggregateOutputType, { nullable: true })
  _sum: CategoryMetadataSumAggregateOutputType | null;
  @Field(() => CategoryMetadataMinAggregateOutputType, { nullable: true })
  _min: CategoryMetadataMinAggregateOutputType | null;
  @Field(() => CategoryMetadataMaxAggregateOutputType, { nullable: true })
  _max: CategoryMetadataMaxAggregateOutputType | null;
}

@ObjectType({})
export class CategoryMetadataGroupByOutputType {
  @Field(() => Int, { nullable: false })
  id: number;
  @Field(() => Date, { nullable: false })
  createdAt: Date;
  @Field(() => Date, { nullable: false })
  updatedAt: Date;
  @Field(() => Int, { nullable: false })
  categoryId: number;
  @Field(() => [GraphQLJSON], { nullable: true })
  metadata: any[] | null;
  @Field(() => CategoryMetadataCountAggregateOutputType, { nullable: true })
  _count: CategoryMetadataCountAggregateOutputType | null;
  @Field(() => CategoryMetadataAvgAggregateOutputType, { nullable: true })
  _avg: CategoryMetadataAvgAggregateOutputType | null;
  @Field(() => CategoryMetadataSumAggregateOutputType, { nullable: true })
  _sum: CategoryMetadataSumAggregateOutputType | null;
  @Field(() => CategoryMetadataMinAggregateOutputType, { nullable: true })
  _min: CategoryMetadataMinAggregateOutputType | null;
  @Field(() => CategoryMetadataMaxAggregateOutputType, { nullable: true })
  _max: CategoryMetadataMaxAggregateOutputType | null;
}

@ObjectType({})
export class AggregateMiscModel {
  @Field(() => MiscModelCountAggregateOutputType, { nullable: true })
  _count: MiscModelCountAggregateOutputType | null;
  @Field(() => MiscModelAvgAggregateOutputType, { nullable: true })
  _avg: MiscModelAvgAggregateOutputType | null;
  @Field(() => MiscModelSumAggregateOutputType, { nullable: true })
  _sum: MiscModelSumAggregateOutputType | null;
  @Field(() => MiscModelMinAggregateOutputType, { nullable: true })
  _min: MiscModelMinAggregateOutputType | null;
  @Field(() => MiscModelMaxAggregateOutputType, { nullable: true })
  _max: MiscModelMaxAggregateOutputType | null;
}

@ObjectType({})
export class MiscModelGroupByOutputType {
  @Field(() => Int, { nullable: false })
  id: number;
  @Field(() => Date, { nullable: false })
  createdAt: Date;
  @Field(() => Date, { nullable: false })
  updatedAt: Date;
  @Field(() => String, { nullable: false })
  name: string;
  @Field(() => GraphQLJSON, { nullable: false })
  jsonField: any;
  @Field(() => [GraphQLJSON], { nullable: true })
  jsonList: any[] | null;
  @Field(() => [String], { nullable: true })
  stringList: string[] | null;
  @Field(() => GraphQLHexadecimal, { nullable: false })
  decimalField: string;
  @Field(() => [GraphQLHexadecimal], { nullable: true })
  decimalList: string[] | null;
  @Field(() => Float, { nullable: false })
  floatField: number;
  @Field(() => GraphQLByte, { nullable: false })
  bytesField: Buffer;
  @Field(() => [GraphQLByte], { nullable: true })
  bytesList: Buffer[] | null;
  @Field(() => GraphQLBigInt, { nullable: false })
  bigIntField: bigint;
  @Field(() => [GraphQLBigInt], { nullable: true })
  bigIntList: bigint[] | null;
  @Field(() => Date, { nullable: false })
  dateTimeField: Date;
  @Field(() => [Date], { nullable: true })
  dateTimeList: Date[] | null;
  @Field(() => MiscModelCountAggregateOutputType, { nullable: true })
  _count: MiscModelCountAggregateOutputType | null;
  @Field(() => MiscModelAvgAggregateOutputType, { nullable: true })
  _avg: MiscModelAvgAggregateOutputType | null;
  @Field(() => MiscModelSumAggregateOutputType, { nullable: true })
  _sum: MiscModelSumAggregateOutputType | null;
  @Field(() => MiscModelMinAggregateOutputType, { nullable: true })
  _min: MiscModelMinAggregateOutputType | null;
  @Field(() => MiscModelMaxAggregateOutputType, { nullable: true })
  _max: MiscModelMaxAggregateOutputType | null;
}

@ObjectType({})
export class AggregateHiddenModel {
  @Field(() => HiddenModelCountAggregateOutputType, { nullable: true })
  _count: HiddenModelCountAggregateOutputType | null;
  @Field(() => HiddenModelAvgAggregateOutputType, { nullable: true })
  _avg: HiddenModelAvgAggregateOutputType | null;
  @Field(() => HiddenModelSumAggregateOutputType, { nullable: true })
  _sum: HiddenModelSumAggregateOutputType | null;
  @Field(() => HiddenModelMinAggregateOutputType, { nullable: true })
  _min: HiddenModelMinAggregateOutputType | null;
  @Field(() => HiddenModelMaxAggregateOutputType, { nullable: true })
  _max: HiddenModelMaxAggregateOutputType | null;
}

@ObjectType({})
export class HiddenModelGroupByOutputType {
  @Field(() => Int, { nullable: false })
  id: number;
  @Field(() => Date, { nullable: false })
  createdAt: Date;
  @Field(() => Date, { nullable: false })
  updatedAt: Date;
  @Field(() => GraphQLJSON, { nullable: false })
  data: any;
  @Field(() => HiddenModelCountAggregateOutputType, { nullable: true })
  _count: HiddenModelCountAggregateOutputType | null;
  @Field(() => HiddenModelAvgAggregateOutputType, { nullable: true })
  _avg: HiddenModelAvgAggregateOutputType | null;
  @Field(() => HiddenModelSumAggregateOutputType, { nullable: true })
  _sum: HiddenModelSumAggregateOutputType | null;
  @Field(() => HiddenModelMinAggregateOutputType, { nullable: true })
  _min: HiddenModelMinAggregateOutputType | null;
  @Field(() => HiddenModelMaxAggregateOutputType, { nullable: true })
  _max: HiddenModelMaxAggregateOutputType | null;
}

@ObjectType({})
export class AffectedRowsOutput {
  @Field(() => Int, { nullable: false })
  count: number;
}

@ObjectType({})
export class UserCountAggregateOutputType {
  @Field(() => Int, { nullable: false })
  id: number;
  @Field(() => Int, { nullable: false })
  createdAt: number;
  @Field(() => Int, { nullable: false })
  updatedAt: number;
  @Field(() => Int, { nullable: false })
  email: number;
  @Field(() => Int, { nullable: false })
  name: number;
  @Field(() => Int, { nullable: false })
  role: number;
  @Field(() => Int, { nullable: false })
  parentId: number;
  @Field(() => Int, { nullable: false })
  mappedField: number;
  @Field(() => Int, { nullable: false })
  _all: number;
}

@ObjectType({})
export class UserAvgAggregateOutputType {
  @Field(() => Float, { nullable: true })
  id: number | null;
  @Field(() => Float, { nullable: true })
  parentId: number | null;
}

@ObjectType({})
export class UserSumAggregateOutputType {
  @Field(() => Int, { nullable: true })
  id: number | null;
  @Field(() => Int, { nullable: true })
  parentId: number | null;
}

@ObjectType({})
export class UserMinAggregateOutputType {
  @Field(() => Int, { nullable: true })
  id: number | null;
  @Field(() => Date, { nullable: true })
  createdAt: Date | null;
  @Field(() => Date, { nullable: true })
  updatedAt: Date | null;
  @Field(() => String, { nullable: true })
  email: string | null;
  @Field(() => String, { nullable: true })
  name: string | null;
  @Field(() => UserRole, { nullable: true })
  role: UserRole | null;
  @Field(() => Int, { nullable: true })
  parentId: number | null;
  @Field(() => String, { nullable: true })
  mappedField: string | null;
}

@ObjectType({})
export class UserMaxAggregateOutputType {
  @Field(() => Int, { nullable: true })
  id: number | null;
  @Field(() => Date, { nullable: true })
  createdAt: Date | null;
  @Field(() => Date, { nullable: true })
  updatedAt: Date | null;
  @Field(() => String, { nullable: true })
  email: string | null;
  @Field(() => String, { nullable: true })
  name: string | null;
  @Field(() => UserRole, { nullable: true })
  role: UserRole | null;
  @Field(() => Int, { nullable: true })
  parentId: number | null;
  @Field(() => String, { nullable: true })
  mappedField: string | null;
}

@ObjectType({})
export class ProfileCountAggregateOutputType {
  @Field(() => Int, { nullable: false })
  id: number;
  @Field(() => Int, { nullable: false })
  createdAt: number;
  @Field(() => Int, { nullable: false })
  updatedAt: number;
  @Field(() => Int, { nullable: false })
  bio: number;
  @Field(() => Int, { nullable: false })
  userId: number;
  @Field(() => Int, { nullable: false })
  _all: number;
}

@ObjectType({})
export class ProfileAvgAggregateOutputType {
  @Field(() => Float, { nullable: true })
  id: number | null;
  @Field(() => Float, { nullable: true })
  userId: number | null;
}

@ObjectType({})
export class ProfileSumAggregateOutputType {
  @Field(() => Int, { nullable: true })
  id: number | null;
  @Field(() => Int, { nullable: true })
  userId: number | null;
}

@ObjectType({})
export class ProfileMinAggregateOutputType {
  @Field(() => Int, { nullable: true })
  id: number | null;
  @Field(() => Date, { nullable: true })
  createdAt: Date | null;
  @Field(() => Date, { nullable: true })
  updatedAt: Date | null;
  @Field(() => String, { nullable: true })
  bio: string | null;
  @Field(() => Int, { nullable: true })
  userId: number | null;
}

@ObjectType({})
export class ProfileMaxAggregateOutputType {
  @Field(() => Int, { nullable: true })
  id: number | null;
  @Field(() => Date, { nullable: true })
  createdAt: Date | null;
  @Field(() => Date, { nullable: true })
  updatedAt: Date | null;
  @Field(() => String, { nullable: true })
  bio: string | null;
  @Field(() => Int, { nullable: true })
  userId: number | null;
}

@ObjectType({})
export class PostCountAggregateOutputType {
  @Field(() => Int, { nullable: false })
  id: number;
  @Field(() => Int, { nullable: false })
  createdAt: number;
  @Field(() => Int, { nullable: false })
  updatedAt: number;
  @Field(() => Int, { nullable: false })
  title: number;
  @Field(() => Int, { nullable: false })
  content: number;
  @Field(() => Int, { nullable: false })
  published: number;
  @Field(() => Int, { nullable: false })
  authorId: number;
  @Field(() => Int, { nullable: false })
  anotherAuthorId: number;
  @Field(() => Int, { nullable: false })
  postKind: number;
  @Field(() => Int, { nullable: false })
  _all: number;
}

@ObjectType({})
export class PostAvgAggregateOutputType {
  @Field(() => Float, { nullable: true })
  id: number | null;
  @Field(() => Float, { nullable: true })
  authorId: number | null;
  @Field(() => Float, { nullable: true })
  anotherAuthorId: number | null;
}

@ObjectType({})
export class PostSumAggregateOutputType {
  @Field(() => Int, { nullable: true })
  id: number | null;
  @Field(() => Int, { nullable: true })
  authorId: number | null;
  @Field(() => Int, { nullable: true })
  anotherAuthorId: number | null;
}

@ObjectType({})
export class PostMinAggregateOutputType {
  @Field(() => Int, { nullable: true })
  id: number | null;
  @Field(() => Date, { nullable: true })
  createdAt: Date | null;
  @Field(() => Date, { nullable: true })
  updatedAt: Date | null;
  @Field(() => String, { nullable: true })
  title: string | null;
  @Field(() => String, { nullable: true })
  content: string | null;
  @Field(() => Boolean, { nullable: true })
  published: boolean | null;
  @Field(() => Int, { nullable: true })
  authorId: number | null;
  @Field(() => Int, { nullable: true })
  anotherAuthorId: number | null;
  @Field(() => PostKind, { nullable: true })
  postKind: PostKind | null;
}

@ObjectType({})
export class PostMaxAggregateOutputType {
  @Field(() => Int, { nullable: true })
  id: number | null;
  @Field(() => Date, { nullable: true })
  createdAt: Date | null;
  @Field(() => Date, { nullable: true })
  updatedAt: Date | null;
  @Field(() => String, { nullable: true })
  title: string | null;
  @Field(() => String, { nullable: true })
  content: string | null;
  @Field(() => Boolean, { nullable: true })
  published: boolean | null;
  @Field(() => Int, { nullable: true })
  authorId: number | null;
  @Field(() => Int, { nullable: true })
  anotherAuthorId: number | null;
  @Field(() => PostKind, { nullable: true })
  postKind: PostKind | null;
}

@ObjectType({})
export class TagCountAggregateOutputType {
  @Field(() => Int, { nullable: false })
  key: number;
  @Field(() => Int, { nullable: false })
  _all: number;
}

@ObjectType({})
export class TagMinAggregateOutputType {
  @Field(() => String, { nullable: true })
  key: string | null;
}

@ObjectType({})
export class TagMaxAggregateOutputType {
  @Field(() => String, { nullable: true })
  key: string | null;
}

@ObjectType({})
export class CategoryCountAggregateOutputType {
  @Field(() => Int, { nullable: false })
  id: number;
  @Field(() => Int, { nullable: false })
  createdAt: number;
  @Field(() => Int, { nullable: false })
  updatedAt: number;
  @Field(() => Int, { nullable: false })
  name: number;
  @Field(() => Int, { nullable: false })
  _all: number;
}

@ObjectType({})
export class CategoryAvgAggregateOutputType {
  @Field(() => Float, { nullable: true })
  id: number | null;
}

@ObjectType({})
export class CategorySumAggregateOutputType {
  @Field(() => Int, { nullable: true })
  id: number | null;
}

@ObjectType({})
export class CategoryMinAggregateOutputType {
  @Field(() => Int, { nullable: true })
  id: number | null;
  @Field(() => Date, { nullable: true })
  createdAt: Date | null;
  @Field(() => Date, { nullable: true })
  updatedAt: Date | null;
  @Field(() => String, { nullable: true })
  name: string | null;
}

@ObjectType({})
export class CategoryMaxAggregateOutputType {
  @Field(() => Int, { nullable: true })
  id: number | null;
  @Field(() => Date, { nullable: true })
  createdAt: Date | null;
  @Field(() => Date, { nullable: true })
  updatedAt: Date | null;
  @Field(() => String, { nullable: true })
  name: string | null;
}

@ObjectType({})
export class CategoryMetadataCountAggregateOutputType {
  @Field(() => Int, { nullable: false })
  id: number;
  @Field(() => Int, { nullable: false })
  createdAt: number;
  @Field(() => Int, { nullable: false })
  updatedAt: number;
  @Field(() => Int, { nullable: false })
  categoryId: number;
  @Field(() => Int, { nullable: false })
  metadata: number;
  @Field(() => Int, { nullable: false })
  _all: number;
}

@ObjectType({})
export class CategoryMetadataAvgAggregateOutputType {
  @Field(() => Float, { nullable: true })
  id: number | null;
  @Field(() => Float, { nullable: true })
  categoryId: number | null;
}

@ObjectType({})
export class CategoryMetadataSumAggregateOutputType {
  @Field(() => Int, { nullable: true })
  id: number | null;
  @Field(() => Int, { nullable: true })
  categoryId: number | null;
}

@ObjectType({})
export class CategoryMetadataMinAggregateOutputType {
  @Field(() => Int, { nullable: true })
  id: number | null;
  @Field(() => Date, { nullable: true })
  createdAt: Date | null;
  @Field(() => Date, { nullable: true })
  updatedAt: Date | null;
  @Field(() => Int, { nullable: true })
  categoryId: number | null;
}

@ObjectType({})
export class CategoryMetadataMaxAggregateOutputType {
  @Field(() => Int, { nullable: true })
  id: number | null;
  @Field(() => Date, { nullable: true })
  createdAt: Date | null;
  @Field(() => Date, { nullable: true })
  updatedAt: Date | null;
  @Field(() => Int, { nullable: true })
  categoryId: number | null;
}

@ObjectType({})
export class MiscModelCountAggregateOutputType {
  @Field(() => Int, { nullable: false })
  id: number;
  @Field(() => Int, { nullable: false })
  createdAt: number;
  @Field(() => Int, { nullable: false })
  updatedAt: number;
  @Field(() => Int, { nullable: false })
  name: number;
  @Field(() => Int, { nullable: false })
  jsonField: number;
  @Field(() => Int, { nullable: false })
  jsonList: number;
  @Field(() => Int, { nullable: false })
  stringList: number;
  @Field(() => Int, { nullable: false })
  decimalField: number;
  @Field(() => Int, { nullable: false })
  decimalList: number;
  @Field(() => Int, { nullable: false })
  floatField: number;
  @Field(() => Int, { nullable: false })
  bytesField: number;
  @Field(() => Int, { nullable: false })
  bytesList: number;
  @Field(() => Int, { nullable: false })
  bigIntField: number;
  @Field(() => Int, { nullable: false })
  bigIntList: number;
  @Field(() => Int, { nullable: false })
  dateTimeField: number;
  @Field(() => Int, { nullable: false })
  dateTimeList: number;
  @Field(() => Int, { nullable: false })
  _all: number;
}

@ObjectType({})
export class MiscModelAvgAggregateOutputType {
  @Field(() => Float, { nullable: true })
  id: number | null;
  @Field(() => GraphQLHexadecimal, { nullable: true })
  decimalField: string | null;
  @Field(() => GraphQLHexadecimal, { nullable: true })
  decimalList: string | null;
  @Field(() => Float, { nullable: true })
  floatField: number | null;
  @Field(() => Float, { nullable: true })
  bigIntField: number | null;
  @Field(() => Float, { nullable: true })
  bigIntList: number | null;
}

@ObjectType({})
export class MiscModelSumAggregateOutputType {
  @Field(() => Int, { nullable: true })
  id: number | null;
  @Field(() => GraphQLHexadecimal, { nullable: true })
  decimalField: string | null;
  @Field(() => [GraphQLHexadecimal], { nullable: true })
  decimalList: string[] | null;
  @Field(() => Float, { nullable: true })
  floatField: number | null;
  @Field(() => GraphQLBigInt, { nullable: true })
  bigIntField: bigint | null;
  @Field(() => [GraphQLBigInt], { nullable: true })
  bigIntList: bigint[] | null;
}

@ObjectType({})
export class MiscModelMinAggregateOutputType {
  @Field(() => Int, { nullable: true })
  id: number | null;
  @Field(() => Date, { nullable: true })
  createdAt: Date | null;
  @Field(() => Date, { nullable: true })
  updatedAt: Date | null;
  @Field(() => String, { nullable: true })
  name: string | null;
  @Field(() => GraphQLHexadecimal, { nullable: true })
  decimalField: string | null;
  @Field(() => Float, { nullable: true })
  floatField: number | null;
  @Field(() => GraphQLByte, { nullable: true })
  bytesField: Buffer | null;
  @Field(() => GraphQLBigInt, { nullable: true })
  bigIntField: bigint | null;
  @Field(() => Date, { nullable: true })
  dateTimeField: Date | null;
}

@ObjectType({})
export class MiscModelMaxAggregateOutputType {
  @Field(() => Int, { nullable: true })
  id: number | null;
  @Field(() => Date, { nullable: true })
  createdAt: Date | null;
  @Field(() => Date, { nullable: true })
  updatedAt: Date | null;
  @Field(() => String, { nullable: true })
  name: string | null;
  @Field(() => GraphQLHexadecimal, { nullable: true })
  decimalField: string | null;
  @Field(() => Float, { nullable: true })
  floatField: number | null;
  @Field(() => GraphQLByte, { nullable: true })
  bytesField: Buffer | null;
  @Field(() => GraphQLBigInt, { nullable: true })
  bigIntField: bigint | null;
  @Field(() => Date, { nullable: true })
  dateTimeField: Date | null;
}

@ObjectType({})
export class HiddenModelCountAggregateOutputType {
  @Field(() => Int, { nullable: false })
  id: number;
  @Field(() => Int, { nullable: false })
  createdAt: number;
  @Field(() => Int, { nullable: false })
  updatedAt: number;
  @Field(() => Int, { nullable: false })
  data: number;
  @Field(() => Int, { nullable: false })
  _all: number;
}

@ObjectType({})
export class HiddenModelAvgAggregateOutputType {
  @Field(() => Float, { nullable: true })
  id: number | null;
}

@ObjectType({})
export class HiddenModelSumAggregateOutputType {
  @Field(() => Int, { nullable: true })
  id: number | null;
}

@ObjectType({})
export class HiddenModelMinAggregateOutputType {
  @Field(() => Int, { nullable: true })
  id: number | null;
  @Field(() => Date, { nullable: true })
  createdAt: Date | null;
  @Field(() => Date, { nullable: true })
  updatedAt: Date | null;
}

@ObjectType({})
export class HiddenModelMaxAggregateOutputType {
  @Field(() => Int, { nullable: true })
  id: number | null;
  @Field(() => Date, { nullable: true })
  createdAt: Date | null;
  @Field(() => Date, { nullable: true })
  updatedAt: Date | null;
}

@ObjectType({ description: 'User model documentation' })
export class User {
  @Field(() => Int, { nullable: false })
  id: number;
  @Field(() => Date, { nullable: false })
  createdAt: Date;
  @Field(() => Date, { nullable: false })
  updatedAt: Date;
  @Field(() => String, { nullable: false })
  email: string;
  @Field(() => String, { nullable: true })
  name: string | null;
  @Field(() => UserRole, { nullable: false })
  role: UserRole;
  @Field(() => Int, { nullable: true })
  parentId: number | null;
  @Field(() => String, { nullable: false })
  mappedField: string;
  @Field(() => [Post], { nullable: true })
  posts: Post[] | null;
  @Field(() => User, { nullable: true })
  parent: User | null;
  @Field(() => [User], { nullable: true })
  children: User[] | null;
  @Field(() => [Post], { nullable: true })
  anotherPosts: Post[] | null;
  @Field(() => [Tag], { nullable: true })
  tags: Tag[] | null;
  @Field(() => Profile, { nullable: true })
  profile: Profile | null;
}

@ObjectType({})
export class Profile {
  @Field(() => Int, { nullable: false })
  id: number;
  @Field(() => Date, { nullable: false })
  createdAt: Date;
  @Field(() => Date, { nullable: false })
  updatedAt: Date;
  @Field(() => String, { nullable: true })
  bio: string | null;
  @Field(() => Int, { nullable: false })
  userId: number;
  @Field(() => User, { nullable: false })
  user: User;
}

@ObjectType({ description: "@@allow('all', auth().role == 'ADMIN')" })
export class Post {
  @Field(() => Int, { nullable: false })
  id: number;
  @Field(() => Date, { nullable: false })
  createdAt: Date;
  @Field(() => Date, { nullable: false })
  updatedAt: Date;
  @Field(() => String, { nullable: false })
  title: string;
  @Field(() => String, { nullable: true })
  content: string | null;
  @Field(() => Boolean, { nullable: false })
  published: boolean;
  @Field(() => Int, { nullable: false })
  authorId: number;
  @Field(() => Int, { nullable: false })
  anotherAuthorId: number;
  @Field(() => PostKind, { nullable: false })
  postKind: PostKind;
  @Field(() => User, { nullable: false })
  author: User;
  @Field(() => User, { nullable: false })
  anotherAuthor: User;
  @Field(() => [Category], { nullable: true })
  categories: Category[] | null;
}

@ObjectType({})
export class Tag {
  @Field(() => String, { nullable: false })
  key: string;
  @Field(() => [User], { nullable: true })
  users: User[] | null;
}

@ObjectType({})
export class Category {
  @Field(() => Int, { nullable: false })
  id: number;
  @Field(() => Date, { nullable: false })
  createdAt: Date;
  @Field(() => Date, { nullable: false })
  updatedAt: Date;
  @Field(() => String, { nullable: false })
  name: string;
  @Field(() => [Post], { nullable: true })
  posts: Post[] | null;
  @Field(() => CategoryMetadata, { nullable: true })
  metadata: CategoryMetadata | null;
}

@ObjectType({})
export class CategoryMetadata {
  @Field(() => Int, { nullable: false })
  id: number;
  @Field(() => Date, { nullable: false })
  createdAt: Date;
  @Field(() => Date, { nullable: false })
  updatedAt: Date;
  @Field(() => Int, { nullable: false })
  categoryId: number;
  @Field(() => [GraphQLJSON], { nullable: true })
  metadata: any[] | null;
  @Field(() => Category, { nullable: false })
  category: Category;
}

@ObjectType({})
export class MiscModel {
  @Field(() => Int, { nullable: false })
  id: number;
  @Field(() => Date, { nullable: false })
  createdAt: Date;
  @Field(() => Date, { nullable: false })
  updatedAt: Date;
  @Field(() => String, { nullable: false })
  name: string;
  @Field(() => GraphQLJSON, { nullable: false })
  jsonField: any;
  @Field(() => [GraphQLJSON], { nullable: true })
  jsonList: any[] | null;
  @Field(() => [String], { nullable: true })
  stringList: string[] | null;
  @Field(() => GraphQLHexadecimal, { nullable: false })
  decimalField: string;
  @Field(() => [GraphQLHexadecimal], { nullable: true })
  decimalList: string[] | null;
  @Field(() => Float, { nullable: false })
  floatField: number;
  @Field(() => GraphQLByte, { nullable: false })
  bytesField: Buffer;
  @Field(() => [GraphQLByte], { nullable: true })
  bytesList: Buffer[] | null;
  @Field(() => GraphQLBigInt, { nullable: false })
  bigIntField: bigint;
  @Field(() => [GraphQLBigInt], { nullable: true })
  bigIntList: bigint[] | null;
  @Field(() => Date, { nullable: false })
  dateTimeField: Date;
  @Field(() => [Date], { nullable: true })
  dateTimeList: Date[] | null;
}

@ObjectType({ description: '@@graphql.hide' })
export class HiddenModel {
  @Field(() => Int, { nullable: false })
  id: number;
  @Field(() => Date, { nullable: false })
  createdAt: Date;
  @Field(() => Date, { nullable: false })
  updatedAt: Date;
  @Field(() => GraphQLJSON, { nullable: false })
  data: any;
}

@InputType()
export class UserWhereInput {
  @Field(() => [UserWhereInput], { nullable: true })
  AND?: UserWhereInput[];
  @Field(() => [UserWhereInput], { nullable: true })
  OR?: UserWhereInput[];
  @Field(() => [UserWhereInput], { nullable: true })
  NOT?: UserWhereInput[];
  @Field(() => IntFilter, { nullable: true })
  id?: IntFilter;
  @Field(() => DateTimeFilter, { nullable: true })
  createdAt?: DateTimeFilter;
  @Field(() => DateTimeFilter, { nullable: true })
  updatedAt?: DateTimeFilter;
  @Field(() => StringFilter, { nullable: true })
  email?: StringFilter;
  @Field(() => StringNullableFilter, { nullable: true })
  name?: StringNullableFilter;
  @Field(() => EnumUserRoleFilter, { nullable: true })
  role?: EnumUserRoleFilter;
  @Field(() => IntNullableFilter, { nullable: true })
  parentId?: IntNullableFilter;
  @Field(() => StringFilter, { nullable: true })
  mappedField?: StringFilter;
  @Field(() => PostListRelationFilter, { nullable: true })
  posts?: PostListRelationFilter;
  @Field(() => UserNullableRelationFilter, { nullable: true })
  parent?: UserNullableRelationFilter;
  @Field(() => UserListRelationFilter, { nullable: true })
  children?: UserListRelationFilter;
  @Field(() => PostListRelationFilter, { nullable: true })
  anotherPosts?: PostListRelationFilter;
  @Field(() => TagListRelationFilter, { nullable: true })
  tags?: TagListRelationFilter;
  @Field(() => ProfileNullableRelationFilter, { nullable: true })
  profile?: ProfileNullableRelationFilter;
}

@InputType()
export class UserOrderByWithRelationInput {
  @Field(() => SortOrder, { nullable: true })
  id?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  createdAt?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  updatedAt?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  email?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  name?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  role?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  parentId?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  mappedField?: SortOrder;
  @Field(() => PostOrderByRelationAggregateInput, { nullable: true })
  posts?: PostOrderByRelationAggregateInput;
  @Field(() => UserOrderByWithRelationInput, { nullable: true })
  parent?: UserOrderByWithRelationInput;
  @Field(() => UserOrderByRelationAggregateInput, { nullable: true })
  children?: UserOrderByRelationAggregateInput;
  @Field(() => PostOrderByRelationAggregateInput, { nullable: true })
  anotherPosts?: PostOrderByRelationAggregateInput;
  @Field(() => TagOrderByRelationAggregateInput, { nullable: true })
  tags?: TagOrderByRelationAggregateInput;
  @Field(() => ProfileOrderByWithRelationInput, { nullable: true })
  profile?: ProfileOrderByWithRelationInput;
}

@InputType()
export class UserWhereUniqueInput {
  @Field(() => Int, { nullable: true })
  id: number;
  @Field(() => String, { nullable: true })
  email: string;
  @Field(() => [UserWhereInput], { nullable: true })
  AND: UserWhereInput[];
  @Field(() => [UserWhereInput], { nullable: true })
  OR: UserWhereInput[];
  @Field(() => [UserWhereInput], { nullable: true })
  NOT: UserWhereInput[];
  @Field(() => DateTimeFilter, { nullable: true })
  createdAt: DateTimeFilter;
  @Field(() => DateTimeFilter, { nullable: true })
  updatedAt: DateTimeFilter;
  @Field(() => StringNullableFilter, { nullable: true })
  name: StringNullableFilter;
  @Field(() => EnumUserRoleFilter, { nullable: true })
  role: EnumUserRoleFilter;
  @Field(() => IntNullableFilter, { nullable: true })
  parentId: IntNullableFilter;
  @Field(() => StringFilter, { nullable: true })
  mappedField: StringFilter;
  @Field(() => PostListRelationFilter, { nullable: true })
  posts: PostListRelationFilter;
  @Field(() => UserNullableRelationFilter, { nullable: true })
  parent: UserNullableRelationFilter;
  @Field(() => UserListRelationFilter, { nullable: true })
  children: UserListRelationFilter;
  @Field(() => PostListRelationFilter, { nullable: true })
  anotherPosts: PostListRelationFilter;
  @Field(() => TagListRelationFilter, { nullable: true })
  tags: TagListRelationFilter;
  @Field(() => ProfileNullableRelationFilter, { nullable: true })
  profile: ProfileNullableRelationFilter;
}

@InputType()
export class UserOrderByWithAggregationInput {
  @Field(() => SortOrder, { nullable: true })
  id?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  createdAt?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  updatedAt?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  email?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  name?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  role?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  parentId?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  mappedField?: SortOrder;
  @Field(() => UserCountOrderByAggregateInput, { nullable: true })
  _count?: UserCountOrderByAggregateInput;
  @Field(() => UserAvgOrderByAggregateInput, { nullable: true })
  _avg?: UserAvgOrderByAggregateInput;
  @Field(() => UserMaxOrderByAggregateInput, { nullable: true })
  _max?: UserMaxOrderByAggregateInput;
  @Field(() => UserMinOrderByAggregateInput, { nullable: true })
  _min?: UserMinOrderByAggregateInput;
  @Field(() => UserSumOrderByAggregateInput, { nullable: true })
  _sum?: UserSumOrderByAggregateInput;
}

@InputType()
export class UserScalarWhereWithAggregatesInput {
  @Field(() => [UserScalarWhereWithAggregatesInput], { nullable: true })
  AND?: UserScalarWhereWithAggregatesInput[];
  @Field(() => [UserScalarWhereWithAggregatesInput], { nullable: true })
  OR?: UserScalarWhereWithAggregatesInput[];
  @Field(() => [UserScalarWhereWithAggregatesInput], { nullable: true })
  NOT?: UserScalarWhereWithAggregatesInput[];
  @Field(() => IntWithAggregatesFilter, { nullable: true })
  id?: IntWithAggregatesFilter;
  @Field(() => DateTimeWithAggregatesFilter, { nullable: true })
  createdAt?: DateTimeWithAggregatesFilter;
  @Field(() => DateTimeWithAggregatesFilter, { nullable: true })
  updatedAt?: DateTimeWithAggregatesFilter;
  @Field(() => StringWithAggregatesFilter, { nullable: true })
  email?: StringWithAggregatesFilter;
  @Field(() => StringNullableWithAggregatesFilter, { nullable: true })
  name?: StringNullableWithAggregatesFilter;
  @Field(() => EnumUserRoleWithAggregatesFilter, { nullable: true })
  role?: EnumUserRoleWithAggregatesFilter;
  @Field(() => IntNullableWithAggregatesFilter, { nullable: true })
  parentId?: IntNullableWithAggregatesFilter;
  @Field(() => StringWithAggregatesFilter, { nullable: true })
  mappedField?: StringWithAggregatesFilter;
}

@InputType()
export class ProfileWhereInput {
  @Field(() => [ProfileWhereInput], { nullable: true })
  AND?: ProfileWhereInput[];
  @Field(() => [ProfileWhereInput], { nullable: true })
  OR?: ProfileWhereInput[];
  @Field(() => [ProfileWhereInput], { nullable: true })
  NOT?: ProfileWhereInput[];
  @Field(() => IntFilter, { nullable: true })
  id?: IntFilter;
  @Field(() => DateTimeFilter, { nullable: true })
  createdAt?: DateTimeFilter;
  @Field(() => DateTimeFilter, { nullable: true })
  updatedAt?: DateTimeFilter;
  @Field(() => StringNullableFilter, { nullable: true })
  bio?: StringNullableFilter;
  @Field(() => IntFilter, { nullable: true })
  userId?: IntFilter;
  @Field(() => UserRelationFilter, { nullable: true })
  user?: UserRelationFilter;
}

@InputType()
export class ProfileOrderByWithRelationInput {
  @Field(() => SortOrder, { nullable: true })
  id?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  createdAt?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  updatedAt?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  bio?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  userId?: SortOrder;
  @Field(() => UserOrderByWithRelationInput, { nullable: true })
  user?: UserOrderByWithRelationInput;
}

@InputType()
export class ProfileWhereUniqueInput {
  @Field(() => Int, { nullable: true })
  id: number;
  @Field(() => Int, { nullable: true })
  userId: number;
  @Field(() => [ProfileWhereInput], { nullable: true })
  AND: ProfileWhereInput[];
  @Field(() => [ProfileWhereInput], { nullable: true })
  OR: ProfileWhereInput[];
  @Field(() => [ProfileWhereInput], { nullable: true })
  NOT: ProfileWhereInput[];
  @Field(() => DateTimeFilter, { nullable: true })
  createdAt: DateTimeFilter;
  @Field(() => DateTimeFilter, { nullable: true })
  updatedAt: DateTimeFilter;
  @Field(() => StringNullableFilter, { nullable: true })
  bio: StringNullableFilter;
  @Field(() => UserRelationFilter, { nullable: true })
  user: UserRelationFilter;
}

@InputType()
export class ProfileOrderByWithAggregationInput {
  @Field(() => SortOrder, { nullable: true })
  id?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  createdAt?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  updatedAt?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  bio?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  userId?: SortOrder;
  @Field(() => ProfileCountOrderByAggregateInput, { nullable: true })
  _count?: ProfileCountOrderByAggregateInput;
  @Field(() => ProfileAvgOrderByAggregateInput, { nullable: true })
  _avg?: ProfileAvgOrderByAggregateInput;
  @Field(() => ProfileMaxOrderByAggregateInput, { nullable: true })
  _max?: ProfileMaxOrderByAggregateInput;
  @Field(() => ProfileMinOrderByAggregateInput, { nullable: true })
  _min?: ProfileMinOrderByAggregateInput;
  @Field(() => ProfileSumOrderByAggregateInput, { nullable: true })
  _sum?: ProfileSumOrderByAggregateInput;
}

@InputType()
export class ProfileScalarWhereWithAggregatesInput {
  @Field(() => [ProfileScalarWhereWithAggregatesInput], { nullable: true })
  AND?: ProfileScalarWhereWithAggregatesInput[];
  @Field(() => [ProfileScalarWhereWithAggregatesInput], { nullable: true })
  OR?: ProfileScalarWhereWithAggregatesInput[];
  @Field(() => [ProfileScalarWhereWithAggregatesInput], { nullable: true })
  NOT?: ProfileScalarWhereWithAggregatesInput[];
  @Field(() => IntWithAggregatesFilter, { nullable: true })
  id?: IntWithAggregatesFilter;
  @Field(() => DateTimeWithAggregatesFilter, { nullable: true })
  createdAt?: DateTimeWithAggregatesFilter;
  @Field(() => DateTimeWithAggregatesFilter, { nullable: true })
  updatedAt?: DateTimeWithAggregatesFilter;
  @Field(() => StringNullableWithAggregatesFilter, { nullable: true })
  bio?: StringNullableWithAggregatesFilter;
  @Field(() => IntWithAggregatesFilter, { nullable: true })
  userId?: IntWithAggregatesFilter;
}

@InputType()
export class PostWhereInput {
  @Field(() => [PostWhereInput], { nullable: true })
  AND?: PostWhereInput[];
  @Field(() => [PostWhereInput], { nullable: true })
  OR?: PostWhereInput[];
  @Field(() => [PostWhereInput], { nullable: true })
  NOT?: PostWhereInput[];
  @Field(() => IntFilter, { nullable: true })
  id?: IntFilter;
  @Field(() => DateTimeFilter, { nullable: true })
  createdAt?: DateTimeFilter;
  @Field(() => DateTimeFilter, { nullable: true })
  updatedAt?: DateTimeFilter;
  @Field(() => StringFilter, { nullable: true })
  title?: StringFilter;
  @Field(() => StringNullableFilter, { nullable: true })
  content?: StringNullableFilter;
  @Field(() => BoolFilter, { nullable: true })
  published?: BoolFilter;
  @Field(() => IntFilter, { nullable: true })
  authorId?: IntFilter;
  @Field(() => IntFilter, { nullable: true })
  anotherAuthorId?: IntFilter;
  @Field(() => EnumPostKindFilter, { nullable: true })
  postKind?: EnumPostKindFilter;
  @Field(() => UserRelationFilter, { nullable: true })
  author?: UserRelationFilter;
  @Field(() => UserRelationFilter, { nullable: true })
  anotherAuthor?: UserRelationFilter;
  @Field(() => CategoryListRelationFilter, { nullable: true })
  categories?: CategoryListRelationFilter;
}

@InputType()
export class PostOrderByWithRelationInput {
  @Field(() => SortOrder, { nullable: true })
  id?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  createdAt?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  updatedAt?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  title?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  content?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  published?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  authorId?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  anotherAuthorId?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  postKind?: SortOrder;
  @Field(() => UserOrderByWithRelationInput, { nullable: true })
  author?: UserOrderByWithRelationInput;
  @Field(() => UserOrderByWithRelationInput, { nullable: true })
  anotherAuthor?: UserOrderByWithRelationInput;
  @Field(() => CategoryOrderByRelationAggregateInput, { nullable: true })
  categories?: CategoryOrderByRelationAggregateInput;
}

@InputType()
export class PostWhereUniqueInput {
  @Field(() => Int, { nullable: true })
  id: number;
  @Field(() => [PostWhereInput], { nullable: true })
  AND: PostWhereInput[];
  @Field(() => [PostWhereInput], { nullable: true })
  OR: PostWhereInput[];
  @Field(() => [PostWhereInput], { nullable: true })
  NOT: PostWhereInput[];
  @Field(() => DateTimeFilter, { nullable: true })
  createdAt: DateTimeFilter;
  @Field(() => DateTimeFilter, { nullable: true })
  updatedAt: DateTimeFilter;
  @Field(() => StringFilter, { nullable: true })
  title: StringFilter;
  @Field(() => StringNullableFilter, { nullable: true })
  content: StringNullableFilter;
  @Field(() => BoolFilter, { nullable: true })
  published: BoolFilter;
  @Field(() => IntFilter, { nullable: true })
  authorId: IntFilter;
  @Field(() => IntFilter, { nullable: true })
  anotherAuthorId: IntFilter;
  @Field(() => EnumPostKindFilter, { nullable: true })
  postKind: EnumPostKindFilter;
  @Field(() => UserRelationFilter, { nullable: true })
  author: UserRelationFilter;
  @Field(() => UserRelationFilter, { nullable: true })
  anotherAuthor: UserRelationFilter;
  @Field(() => CategoryListRelationFilter, { nullable: true })
  categories: CategoryListRelationFilter;
}

@InputType()
export class PostOrderByWithAggregationInput {
  @Field(() => SortOrder, { nullable: true })
  id?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  createdAt?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  updatedAt?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  title?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  content?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  published?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  authorId?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  anotherAuthorId?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  postKind?: SortOrder;
  @Field(() => PostCountOrderByAggregateInput, { nullable: true })
  _count?: PostCountOrderByAggregateInput;
  @Field(() => PostAvgOrderByAggregateInput, { nullable: true })
  _avg?: PostAvgOrderByAggregateInput;
  @Field(() => PostMaxOrderByAggregateInput, { nullable: true })
  _max?: PostMaxOrderByAggregateInput;
  @Field(() => PostMinOrderByAggregateInput, { nullable: true })
  _min?: PostMinOrderByAggregateInput;
  @Field(() => PostSumOrderByAggregateInput, { nullable: true })
  _sum?: PostSumOrderByAggregateInput;
}

@InputType()
export class PostScalarWhereWithAggregatesInput {
  @Field(() => [PostScalarWhereWithAggregatesInput], { nullable: true })
  AND?: PostScalarWhereWithAggregatesInput[];
  @Field(() => [PostScalarWhereWithAggregatesInput], { nullable: true })
  OR?: PostScalarWhereWithAggregatesInput[];
  @Field(() => [PostScalarWhereWithAggregatesInput], { nullable: true })
  NOT?: PostScalarWhereWithAggregatesInput[];
  @Field(() => IntWithAggregatesFilter, { nullable: true })
  id?: IntWithAggregatesFilter;
  @Field(() => DateTimeWithAggregatesFilter, { nullable: true })
  createdAt?: DateTimeWithAggregatesFilter;
  @Field(() => DateTimeWithAggregatesFilter, { nullable: true })
  updatedAt?: DateTimeWithAggregatesFilter;
  @Field(() => StringWithAggregatesFilter, { nullable: true })
  title?: StringWithAggregatesFilter;
  @Field(() => StringNullableWithAggregatesFilter, { nullable: true })
  content?: StringNullableWithAggregatesFilter;
  @Field(() => BoolWithAggregatesFilter, { nullable: true })
  published?: BoolWithAggregatesFilter;
  @Field(() => IntWithAggregatesFilter, { nullable: true })
  authorId?: IntWithAggregatesFilter;
  @Field(() => IntWithAggregatesFilter, { nullable: true })
  anotherAuthorId?: IntWithAggregatesFilter;
  @Field(() => EnumPostKindWithAggregatesFilter, { nullable: true })
  postKind?: EnumPostKindWithAggregatesFilter;
}

@InputType()
export class TagWhereInput {
  @Field(() => [TagWhereInput], { nullable: true })
  AND?: TagWhereInput[];
  @Field(() => [TagWhereInput], { nullable: true })
  OR?: TagWhereInput[];
  @Field(() => [TagWhereInput], { nullable: true })
  NOT?: TagWhereInput[];
  @Field(() => StringFilter, { nullable: true })
  key?: StringFilter;
  @Field(() => UserListRelationFilter, { nullable: true })
  users?: UserListRelationFilter;
}

@InputType()
export class TagOrderByWithRelationInput {
  @Field(() => SortOrder, { nullable: true })
  key?: SortOrder;
  @Field(() => UserOrderByRelationAggregateInput, { nullable: true })
  users?: UserOrderByRelationAggregateInput;
}

@InputType()
export class TagWhereUniqueInput {
  @Field(() => String, { nullable: true })
  key: string;
  @Field(() => [TagWhereInput], { nullable: true })
  AND: TagWhereInput[];
  @Field(() => [TagWhereInput], { nullable: true })
  OR: TagWhereInput[];
  @Field(() => [TagWhereInput], { nullable: true })
  NOT: TagWhereInput[];
  @Field(() => UserListRelationFilter, { nullable: true })
  users: UserListRelationFilter;
}

@InputType()
export class TagOrderByWithAggregationInput {
  @Field(() => SortOrder, { nullable: true })
  key?: SortOrder;
  @Field(() => TagCountOrderByAggregateInput, { nullable: true })
  _count?: TagCountOrderByAggregateInput;
  @Field(() => TagMaxOrderByAggregateInput, { nullable: true })
  _max?: TagMaxOrderByAggregateInput;
  @Field(() => TagMinOrderByAggregateInput, { nullable: true })
  _min?: TagMinOrderByAggregateInput;
}

@InputType()
export class TagScalarWhereWithAggregatesInput {
  @Field(() => [TagScalarWhereWithAggregatesInput], { nullable: true })
  AND?: TagScalarWhereWithAggregatesInput[];
  @Field(() => [TagScalarWhereWithAggregatesInput], { nullable: true })
  OR?: TagScalarWhereWithAggregatesInput[];
  @Field(() => [TagScalarWhereWithAggregatesInput], { nullable: true })
  NOT?: TagScalarWhereWithAggregatesInput[];
  @Field(() => StringWithAggregatesFilter, { nullable: true })
  key?: StringWithAggregatesFilter;
}

@InputType()
export class CategoryWhereInput {
  @Field(() => [CategoryWhereInput], { nullable: true })
  AND?: CategoryWhereInput[];
  @Field(() => [CategoryWhereInput], { nullable: true })
  OR?: CategoryWhereInput[];
  @Field(() => [CategoryWhereInput], { nullable: true })
  NOT?: CategoryWhereInput[];
  @Field(() => IntFilter, { nullable: true })
  id?: IntFilter;
  @Field(() => DateTimeFilter, { nullable: true })
  createdAt?: DateTimeFilter;
  @Field(() => DateTimeFilter, { nullable: true })
  updatedAt?: DateTimeFilter;
  @Field(() => StringFilter, { nullable: true })
  name?: StringFilter;
  @Field(() => PostListRelationFilter, { nullable: true })
  posts?: PostListRelationFilter;
  @Field(() => CategoryMetadataNullableRelationFilter, { nullable: true })
  metadata?: CategoryMetadataNullableRelationFilter;
}

@InputType()
export class CategoryOrderByWithRelationInput {
  @Field(() => SortOrder, { nullable: true })
  id?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  createdAt?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  updatedAt?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  name?: SortOrder;
  @Field(() => PostOrderByRelationAggregateInput, { nullable: true })
  posts?: PostOrderByRelationAggregateInput;
  @Field(() => CategoryMetadataOrderByWithRelationInput, { nullable: true })
  metadata?: CategoryMetadataOrderByWithRelationInput;
}

@InputType()
export class CategoryWhereUniqueInput {
  @Field(() => Int, { nullable: true })
  id: number;
  @Field(() => String, { nullable: true })
  name: string;
  @Field(() => [CategoryWhereInput], { nullable: true })
  AND: CategoryWhereInput[];
  @Field(() => [CategoryWhereInput], { nullable: true })
  OR: CategoryWhereInput[];
  @Field(() => [CategoryWhereInput], { nullable: true })
  NOT: CategoryWhereInput[];
  @Field(() => DateTimeFilter, { nullable: true })
  createdAt: DateTimeFilter;
  @Field(() => DateTimeFilter, { nullable: true })
  updatedAt: DateTimeFilter;
  @Field(() => PostListRelationFilter, { nullable: true })
  posts: PostListRelationFilter;
  @Field(() => CategoryMetadataNullableRelationFilter, { nullable: true })
  metadata: CategoryMetadataNullableRelationFilter;
}

@InputType()
export class CategoryOrderByWithAggregationInput {
  @Field(() => SortOrder, { nullable: true })
  id?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  createdAt?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  updatedAt?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  name?: SortOrder;
  @Field(() => CategoryCountOrderByAggregateInput, { nullable: true })
  _count?: CategoryCountOrderByAggregateInput;
  @Field(() => CategoryAvgOrderByAggregateInput, { nullable: true })
  _avg?: CategoryAvgOrderByAggregateInput;
  @Field(() => CategoryMaxOrderByAggregateInput, { nullable: true })
  _max?: CategoryMaxOrderByAggregateInput;
  @Field(() => CategoryMinOrderByAggregateInput, { nullable: true })
  _min?: CategoryMinOrderByAggregateInput;
  @Field(() => CategorySumOrderByAggregateInput, { nullable: true })
  _sum?: CategorySumOrderByAggregateInput;
}

@InputType()
export class CategoryScalarWhereWithAggregatesInput {
  @Field(() => [CategoryScalarWhereWithAggregatesInput], { nullable: true })
  AND?: CategoryScalarWhereWithAggregatesInput[];
  @Field(() => [CategoryScalarWhereWithAggregatesInput], { nullable: true })
  OR?: CategoryScalarWhereWithAggregatesInput[];
  @Field(() => [CategoryScalarWhereWithAggregatesInput], { nullable: true })
  NOT?: CategoryScalarWhereWithAggregatesInput[];
  @Field(() => IntWithAggregatesFilter, { nullable: true })
  id?: IntWithAggregatesFilter;
  @Field(() => DateTimeWithAggregatesFilter, { nullable: true })
  createdAt?: DateTimeWithAggregatesFilter;
  @Field(() => DateTimeWithAggregatesFilter, { nullable: true })
  updatedAt?: DateTimeWithAggregatesFilter;
  @Field(() => StringWithAggregatesFilter, { nullable: true })
  name?: StringWithAggregatesFilter;
}

@InputType()
export class CategoryMetadataWhereInput {
  @Field(() => [CategoryMetadataWhereInput], { nullable: true })
  AND?: CategoryMetadataWhereInput[];
  @Field(() => [CategoryMetadataWhereInput], { nullable: true })
  OR?: CategoryMetadataWhereInput[];
  @Field(() => [CategoryMetadataWhereInput], { nullable: true })
  NOT?: CategoryMetadataWhereInput[];
  @Field(() => IntFilter, { nullable: true })
  id?: IntFilter;
  @Field(() => DateTimeFilter, { nullable: true })
  createdAt?: DateTimeFilter;
  @Field(() => DateTimeFilter, { nullable: true })
  updatedAt?: DateTimeFilter;
  @Field(() => IntFilter, { nullable: true })
  categoryId?: IntFilter;
  @Field(() => JsonNullableListFilter, { nullable: true })
  metadata?: JsonNullableListFilter;
  @Field(() => CategoryRelationFilter, { nullable: true })
  category?: CategoryRelationFilter;
}

@InputType()
export class CategoryMetadataOrderByWithRelationInput {
  @Field(() => SortOrder, { nullable: true })
  id?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  createdAt?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  updatedAt?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  categoryId?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  metadata?: SortOrder;
  @Field(() => CategoryOrderByWithRelationInput, { nullable: true })
  category?: CategoryOrderByWithRelationInput;
}

@InputType()
export class CategoryMetadataWhereUniqueInput {
  @Field(() => Int, { nullable: true })
  id: number;
  @Field(() => Int, { nullable: true })
  categoryId: number;
  @Field(() => [CategoryMetadataWhereInput], { nullable: true })
  AND: CategoryMetadataWhereInput[];
  @Field(() => [CategoryMetadataWhereInput], { nullable: true })
  OR: CategoryMetadataWhereInput[];
  @Field(() => [CategoryMetadataWhereInput], { nullable: true })
  NOT: CategoryMetadataWhereInput[];
  @Field(() => DateTimeFilter, { nullable: true })
  createdAt: DateTimeFilter;
  @Field(() => DateTimeFilter, { nullable: true })
  updatedAt: DateTimeFilter;
  @Field(() => JsonNullableListFilter, { nullable: true })
  metadata: JsonNullableListFilter;
  @Field(() => CategoryRelationFilter, { nullable: true })
  category: CategoryRelationFilter;
}

@InputType()
export class CategoryMetadataOrderByWithAggregationInput {
  @Field(() => SortOrder, { nullable: true })
  id?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  createdAt?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  updatedAt?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  categoryId?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  metadata?: SortOrder;
  @Field(() => CategoryMetadataCountOrderByAggregateInput, { nullable: true })
  _count?: CategoryMetadataCountOrderByAggregateInput;
  @Field(() => CategoryMetadataAvgOrderByAggregateInput, { nullable: true })
  _avg?: CategoryMetadataAvgOrderByAggregateInput;
  @Field(() => CategoryMetadataMaxOrderByAggregateInput, { nullable: true })
  _max?: CategoryMetadataMaxOrderByAggregateInput;
  @Field(() => CategoryMetadataMinOrderByAggregateInput, { nullable: true })
  _min?: CategoryMetadataMinOrderByAggregateInput;
  @Field(() => CategoryMetadataSumOrderByAggregateInput, { nullable: true })
  _sum?: CategoryMetadataSumOrderByAggregateInput;
}

@InputType()
export class CategoryMetadataScalarWhereWithAggregatesInput {
  @Field(() => [CategoryMetadataScalarWhereWithAggregatesInput], {
    nullable: true,
  })
  AND?: CategoryMetadataScalarWhereWithAggregatesInput[];
  @Field(() => [CategoryMetadataScalarWhereWithAggregatesInput], {
    nullable: true,
  })
  OR?: CategoryMetadataScalarWhereWithAggregatesInput[];
  @Field(() => [CategoryMetadataScalarWhereWithAggregatesInput], {
    nullable: true,
  })
  NOT?: CategoryMetadataScalarWhereWithAggregatesInput[];
  @Field(() => IntWithAggregatesFilter, { nullable: true })
  id?: IntWithAggregatesFilter;
  @Field(() => DateTimeWithAggregatesFilter, { nullable: true })
  createdAt?: DateTimeWithAggregatesFilter;
  @Field(() => DateTimeWithAggregatesFilter, { nullable: true })
  updatedAt?: DateTimeWithAggregatesFilter;
  @Field(() => IntWithAggregatesFilter, { nullable: true })
  categoryId?: IntWithAggregatesFilter;
  @Field(() => JsonNullableListFilter, { nullable: true })
  metadata?: JsonNullableListFilter;
}

@InputType()
export class MiscModelWhereInput {
  @Field(() => [MiscModelWhereInput], { nullable: true })
  AND?: MiscModelWhereInput[];
  @Field(() => [MiscModelWhereInput], { nullable: true })
  OR?: MiscModelWhereInput[];
  @Field(() => [MiscModelWhereInput], { nullable: true })
  NOT?: MiscModelWhereInput[];
  @Field(() => IntFilter, { nullable: true })
  id?: IntFilter;
  @Field(() => DateTimeFilter, { nullable: true })
  createdAt?: DateTimeFilter;
  @Field(() => DateTimeFilter, { nullable: true })
  updatedAt?: DateTimeFilter;
  @Field(() => StringFilter, { nullable: true })
  name?: StringFilter;
  @Field(() => JsonFilter, { nullable: true })
  jsonField?: JsonFilter;
  @Field(() => JsonNullableListFilter, { nullable: true })
  jsonList?: JsonNullableListFilter;
  @Field(() => StringNullableListFilter, { nullable: true })
  stringList?: StringNullableListFilter;
  @Field(() => DecimalFilter, { nullable: true })
  decimalField?: DecimalFilter;
  @Field(() => DecimalNullableListFilter, { nullable: true })
  decimalList?: DecimalNullableListFilter;
  @Field(() => FloatFilter, { nullable: true })
  floatField?: FloatFilter;
  @Field(() => BytesFilter, { nullable: true })
  bytesField?: BytesFilter;
  @Field(() => BytesNullableListFilter, { nullable: true })
  bytesList?: BytesNullableListFilter;
  @Field(() => BigIntFilter, { nullable: true })
  bigIntField?: BigIntFilter;
  @Field(() => BigIntNullableListFilter, { nullable: true })
  bigIntList?: BigIntNullableListFilter;
  @Field(() => DateTimeFilter, { nullable: true })
  dateTimeField?: DateTimeFilter;
  @Field(() => DateTimeNullableListFilter, { nullable: true })
  dateTimeList?: DateTimeNullableListFilter;
}

@InputType()
export class MiscModelOrderByWithRelationInput {
  @Field(() => SortOrder, { nullable: true })
  id?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  createdAt?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  updatedAt?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  name?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  jsonField?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  jsonList?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  stringList?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  decimalField?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  decimalList?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  floatField?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  bytesField?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  bytesList?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  bigIntField?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  bigIntList?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  dateTimeField?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  dateTimeList?: SortOrder;
}

@InputType()
export class MiscModelWhereUniqueInput {
  @Field(() => Int, { nullable: true })
  id: number;
  @Field(() => [MiscModelWhereInput], { nullable: true })
  AND: MiscModelWhereInput[];
  @Field(() => [MiscModelWhereInput], { nullable: true })
  OR: MiscModelWhereInput[];
  @Field(() => [MiscModelWhereInput], { nullable: true })
  NOT: MiscModelWhereInput[];
  @Field(() => DateTimeFilter, { nullable: true })
  createdAt: DateTimeFilter;
  @Field(() => DateTimeFilter, { nullable: true })
  updatedAt: DateTimeFilter;
  @Field(() => StringFilter, { nullable: true })
  name: StringFilter;
  @Field(() => JsonFilter, { nullable: true })
  jsonField: JsonFilter;
  @Field(() => JsonNullableListFilter, { nullable: true })
  jsonList: JsonNullableListFilter;
  @Field(() => StringNullableListFilter, { nullable: true })
  stringList: StringNullableListFilter;
  @Field(() => DecimalFilter, { nullable: true })
  decimalField: DecimalFilter;
  @Field(() => DecimalNullableListFilter, { nullable: true })
  decimalList: DecimalNullableListFilter;
  @Field(() => FloatFilter, { nullable: true })
  floatField: FloatFilter;
  @Field(() => BytesFilter, { nullable: true })
  bytesField: BytesFilter;
  @Field(() => BytesNullableListFilter, { nullable: true })
  bytesList: BytesNullableListFilter;
  @Field(() => BigIntFilter, { nullable: true })
  bigIntField: BigIntFilter;
  @Field(() => BigIntNullableListFilter, { nullable: true })
  bigIntList: BigIntNullableListFilter;
  @Field(() => DateTimeFilter, { nullable: true })
  dateTimeField: DateTimeFilter;
  @Field(() => DateTimeNullableListFilter, { nullable: true })
  dateTimeList: DateTimeNullableListFilter;
}

@InputType()
export class MiscModelOrderByWithAggregationInput {
  @Field(() => SortOrder, { nullable: true })
  id?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  createdAt?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  updatedAt?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  name?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  jsonField?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  jsonList?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  stringList?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  decimalField?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  decimalList?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  floatField?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  bytesField?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  bytesList?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  bigIntField?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  bigIntList?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  dateTimeField?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  dateTimeList?: SortOrder;
  @Field(() => MiscModelCountOrderByAggregateInput, { nullable: true })
  _count?: MiscModelCountOrderByAggregateInput;
  @Field(() => MiscModelAvgOrderByAggregateInput, { nullable: true })
  _avg?: MiscModelAvgOrderByAggregateInput;
  @Field(() => MiscModelMaxOrderByAggregateInput, { nullable: true })
  _max?: MiscModelMaxOrderByAggregateInput;
  @Field(() => MiscModelMinOrderByAggregateInput, { nullable: true })
  _min?: MiscModelMinOrderByAggregateInput;
  @Field(() => MiscModelSumOrderByAggregateInput, { nullable: true })
  _sum?: MiscModelSumOrderByAggregateInput;
}

@InputType()
export class MiscModelScalarWhereWithAggregatesInput {
  @Field(() => [MiscModelScalarWhereWithAggregatesInput], { nullable: true })
  AND?: MiscModelScalarWhereWithAggregatesInput[];
  @Field(() => [MiscModelScalarWhereWithAggregatesInput], { nullable: true })
  OR?: MiscModelScalarWhereWithAggregatesInput[];
  @Field(() => [MiscModelScalarWhereWithAggregatesInput], { nullable: true })
  NOT?: MiscModelScalarWhereWithAggregatesInput[];
  @Field(() => IntWithAggregatesFilter, { nullable: true })
  id?: IntWithAggregatesFilter;
  @Field(() => DateTimeWithAggregatesFilter, { nullable: true })
  createdAt?: DateTimeWithAggregatesFilter;
  @Field(() => DateTimeWithAggregatesFilter, { nullable: true })
  updatedAt?: DateTimeWithAggregatesFilter;
  @Field(() => StringWithAggregatesFilter, { nullable: true })
  name?: StringWithAggregatesFilter;
  @Field(() => JsonWithAggregatesFilter, { nullable: true })
  jsonField?: JsonWithAggregatesFilter;
  @Field(() => JsonNullableListFilter, { nullable: true })
  jsonList?: JsonNullableListFilter;
  @Field(() => StringNullableListFilter, { nullable: true })
  stringList?: StringNullableListFilter;
  @Field(() => DecimalWithAggregatesFilter, { nullable: true })
  decimalField?: DecimalWithAggregatesFilter;
  @Field(() => DecimalNullableListFilter, { nullable: true })
  decimalList?: DecimalNullableListFilter;
  @Field(() => FloatWithAggregatesFilter, { nullable: true })
  floatField?: FloatWithAggregatesFilter;
  @Field(() => BytesWithAggregatesFilter, { nullable: true })
  bytesField?: BytesWithAggregatesFilter;
  @Field(() => BytesNullableListFilter, { nullable: true })
  bytesList?: BytesNullableListFilter;
  @Field(() => BigIntWithAggregatesFilter, { nullable: true })
  bigIntField?: BigIntWithAggregatesFilter;
  @Field(() => BigIntNullableListFilter, { nullable: true })
  bigIntList?: BigIntNullableListFilter;
  @Field(() => DateTimeWithAggregatesFilter, { nullable: true })
  dateTimeField?: DateTimeWithAggregatesFilter;
  @Field(() => DateTimeNullableListFilter, { nullable: true })
  dateTimeList?: DateTimeNullableListFilter;
}

@InputType()
export class HiddenModelWhereInput {
  @Field(() => [HiddenModelWhereInput], { nullable: true })
  AND?: HiddenModelWhereInput[];
  @Field(() => [HiddenModelWhereInput], { nullable: true })
  OR?: HiddenModelWhereInput[];
  @Field(() => [HiddenModelWhereInput], { nullable: true })
  NOT?: HiddenModelWhereInput[];
  @Field(() => IntFilter, { nullable: true })
  id?: IntFilter;
  @Field(() => DateTimeFilter, { nullable: true })
  createdAt?: DateTimeFilter;
  @Field(() => DateTimeFilter, { nullable: true })
  updatedAt?: DateTimeFilter;
  @Field(() => JsonFilter, { nullable: true })
  data?: JsonFilter;
}

@InputType()
export class HiddenModelOrderByWithRelationInput {
  @Field(() => SortOrder, { nullable: true })
  id?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  createdAt?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  updatedAt?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  data?: SortOrder;
}

@InputType()
export class HiddenModelWhereUniqueInput {
  @Field(() => Int, { nullable: true })
  id: number;
  @Field(() => [HiddenModelWhereInput], { nullable: true })
  AND: HiddenModelWhereInput[];
  @Field(() => [HiddenModelWhereInput], { nullable: true })
  OR: HiddenModelWhereInput[];
  @Field(() => [HiddenModelWhereInput], { nullable: true })
  NOT: HiddenModelWhereInput[];
  @Field(() => DateTimeFilter, { nullable: true })
  createdAt: DateTimeFilter;
  @Field(() => DateTimeFilter, { nullable: true })
  updatedAt: DateTimeFilter;
  @Field(() => JsonFilter, { nullable: true })
  data: JsonFilter;
}

@InputType()
export class HiddenModelOrderByWithAggregationInput {
  @Field(() => SortOrder, { nullable: true })
  id?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  createdAt?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  updatedAt?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  data?: SortOrder;
  @Field(() => HiddenModelCountOrderByAggregateInput, { nullable: true })
  _count?: HiddenModelCountOrderByAggregateInput;
  @Field(() => HiddenModelAvgOrderByAggregateInput, { nullable: true })
  _avg?: HiddenModelAvgOrderByAggregateInput;
  @Field(() => HiddenModelMaxOrderByAggregateInput, { nullable: true })
  _max?: HiddenModelMaxOrderByAggregateInput;
  @Field(() => HiddenModelMinOrderByAggregateInput, { nullable: true })
  _min?: HiddenModelMinOrderByAggregateInput;
  @Field(() => HiddenModelSumOrderByAggregateInput, { nullable: true })
  _sum?: HiddenModelSumOrderByAggregateInput;
}

@InputType()
export class HiddenModelScalarWhereWithAggregatesInput {
  @Field(() => [HiddenModelScalarWhereWithAggregatesInput], { nullable: true })
  AND?: HiddenModelScalarWhereWithAggregatesInput[];
  @Field(() => [HiddenModelScalarWhereWithAggregatesInput], { nullable: true })
  OR?: HiddenModelScalarWhereWithAggregatesInput[];
  @Field(() => [HiddenModelScalarWhereWithAggregatesInput], { nullable: true })
  NOT?: HiddenModelScalarWhereWithAggregatesInput[];
  @Field(() => IntWithAggregatesFilter, { nullable: true })
  id?: IntWithAggregatesFilter;
  @Field(() => DateTimeWithAggregatesFilter, { nullable: true })
  createdAt?: DateTimeWithAggregatesFilter;
  @Field(() => DateTimeWithAggregatesFilter, { nullable: true })
  updatedAt?: DateTimeWithAggregatesFilter;
  @Field(() => JsonWithAggregatesFilter, { nullable: true })
  data?: JsonWithAggregatesFilter;
}

@InputType()
export class UserCreateManyInput {
  @Field(() => Int, { nullable: true })
  id?: number;
  @Field(() => Date, { nullable: true })
  createdAt?: Date;
  @Field(() => Date, { nullable: true })
  updatedAt?: Date;
  @Field(() => String, { nullable: false })
  email: string;
  @Field(() => String, { nullable: true })
  name?: string;
  @Field(() => UserRole, { nullable: true })
  role?: UserRole;
  @Field(() => Int, { nullable: true })
  parentId?: number;
  @Field(() => String, { nullable: false })
  mappedField: string;
}

@InputType()
export class UserUpdateManyMutationInput {
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  createdAt?: DateTimeFieldUpdateOperationsInput;
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  updatedAt?: DateTimeFieldUpdateOperationsInput;
  @Field(() => StringFieldUpdateOperationsInput, { nullable: true })
  email?: StringFieldUpdateOperationsInput;
  @Field(() => NullableStringFieldUpdateOperationsInput, { nullable: true })
  name?: NullableStringFieldUpdateOperationsInput;
  @Field(() => UserRole, { nullable: true })
  role?: UserRole;
  @Field(() => StringFieldUpdateOperationsInput, { nullable: true })
  mappedField?: StringFieldUpdateOperationsInput;
}

@InputType()
export class ProfileCreateManyInput {
  @Field(() => Int, { nullable: true })
  id?: number;
  @Field(() => Date, { nullable: true })
  createdAt?: Date;
  @Field(() => Date, { nullable: true })
  updatedAt?: Date;
  @Field(() => String, { nullable: true })
  bio?: string;
  @Field(() => Int, { nullable: false })
  userId: number;
}

@InputType()
export class ProfileUpdateManyMutationInput {
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  createdAt?: DateTimeFieldUpdateOperationsInput;
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  updatedAt?: DateTimeFieldUpdateOperationsInput;
  @Field(() => NullableStringFieldUpdateOperationsInput, { nullable: true })
  bio?: NullableStringFieldUpdateOperationsInput;
}

@InputType()
export class PostCreateManyInput {
  @Field(() => Int, { nullable: true })
  id?: number;
  @Field(() => Date, { nullable: true })
  createdAt?: Date;
  @Field(() => Date, { nullable: true })
  updatedAt?: Date;
  @Field(() => String, { nullable: false })
  title: string;
  @Field(() => String, { nullable: true })
  content?: string;
  @Field(() => Boolean, { nullable: true })
  published?: boolean;
  @Field(() => Int, { nullable: false })
  authorId: number;
  @Field(() => Int, { nullable: false })
  anotherAuthorId: number;
  @Field(() => PostKind, { nullable: false })
  postKind: PostKind;
}

@InputType()
export class PostUpdateManyMutationInput {
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  createdAt?: DateTimeFieldUpdateOperationsInput;
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  updatedAt?: DateTimeFieldUpdateOperationsInput;
  @Field(() => StringFieldUpdateOperationsInput, { nullable: true })
  title?: StringFieldUpdateOperationsInput;
  @Field(() => NullableStringFieldUpdateOperationsInput, { nullable: true })
  content?: NullableStringFieldUpdateOperationsInput;
  @Field(() => BoolFieldUpdateOperationsInput, { nullable: true })
  published?: BoolFieldUpdateOperationsInput;
  @Field(() => PostKind, { nullable: true })
  postKind?: PostKind;
}

@InputType()
export class TagCreateManyInput {
  @Field(() => String, { nullable: false })
  key: string;
}

@InputType()
export class TagUpdateManyMutationInput {
  @Field(() => StringFieldUpdateOperationsInput, { nullable: true })
  key?: StringFieldUpdateOperationsInput;
}

@InputType()
export class CategoryCreateManyInput {
  @Field(() => Int, { nullable: true })
  id?: number;
  @Field(() => Date, { nullable: true })
  createdAt?: Date;
  @Field(() => Date, { nullable: true })
  updatedAt?: Date;
  @Field(() => String, { nullable: false })
  name: string;
}

@InputType()
export class CategoryUpdateManyMutationInput {
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  createdAt?: DateTimeFieldUpdateOperationsInput;
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  updatedAt?: DateTimeFieldUpdateOperationsInput;
  @Field(() => StringFieldUpdateOperationsInput, { nullable: true })
  name?: StringFieldUpdateOperationsInput;
}

@InputType()
export class CategoryMetadataCreateManyInput {
  @Field(() => Int, { nullable: true })
  id?: number;
  @Field(() => Date, { nullable: true })
  createdAt?: Date;
  @Field(() => Date, { nullable: true })
  updatedAt?: Date;
  @Field(() => Int, { nullable: false })
  categoryId: number;
  @Field(() => CategoryMetadataCreatemetadataInput, { nullable: true })
  metadata?: CategoryMetadataCreatemetadataInput;
}

@InputType()
export class CategoryMetadataUpdateManyMutationInput {
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  createdAt?: DateTimeFieldUpdateOperationsInput;
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  updatedAt?: DateTimeFieldUpdateOperationsInput;
  @Field(() => CategoryMetadataUpdatemetadataInput, { nullable: true })
  metadata?: CategoryMetadataUpdatemetadataInput;
}

@InputType()
export class MiscModelCreateManyInput {
  @Field(() => Int, { nullable: true })
  id?: number;
  @Field(() => Date, { nullable: true })
  createdAt?: Date;
  @Field(() => Date, { nullable: true })
  updatedAt?: Date;
  @Field(() => String, { nullable: false })
  name: string;
  @Field(() => GraphQLJSON, { nullable: false })
  jsonField: any;
  @Field(() => MiscModelCreatejsonListInput, { nullable: true })
  jsonList?: MiscModelCreatejsonListInput;
  @Field(() => MiscModelCreatestringListInput, { nullable: true })
  stringList?: MiscModelCreatestringListInput;
  @Field(() => GraphQLHexadecimal, { nullable: false })
  decimalField: string;
  @Field(() => MiscModelCreatedecimalListInput, { nullable: true })
  decimalList?: MiscModelCreatedecimalListInput;
  @Field(() => Float, { nullable: false })
  floatField: number;
  @Field(() => GraphQLByte, { nullable: false })
  bytesField: Buffer;
  @Field(() => MiscModelCreatebytesListInput, { nullable: true })
  bytesList?: MiscModelCreatebytesListInput;
  @Field(() => GraphQLBigInt, { nullable: false })
  bigIntField: bigint;
  @Field(() => MiscModelCreatebigIntListInput, { nullable: true })
  bigIntList?: MiscModelCreatebigIntListInput;
  @Field(() => Date, { nullable: false })
  dateTimeField: Date;
  @Field(() => MiscModelCreatedateTimeListInput, { nullable: true })
  dateTimeList?: MiscModelCreatedateTimeListInput;
}

@InputType()
export class MiscModelUpdateManyMutationInput {
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  createdAt?: DateTimeFieldUpdateOperationsInput;
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  updatedAt?: DateTimeFieldUpdateOperationsInput;
  @Field(() => StringFieldUpdateOperationsInput, { nullable: true })
  name?: StringFieldUpdateOperationsInput;
  @Field(() => GraphQLJSON, { nullable: true })
  jsonField?: any;
  @Field(() => MiscModelUpdatejsonListInput, { nullable: true })
  jsonList?: MiscModelUpdatejsonListInput;
  @Field(() => MiscModelUpdatestringListInput, { nullable: true })
  stringList?: MiscModelUpdatestringListInput;
  @Field(() => DecimalFieldUpdateOperationsInput, { nullable: true })
  decimalField?: DecimalFieldUpdateOperationsInput;
  @Field(() => MiscModelUpdatedecimalListInput, { nullable: true })
  decimalList?: MiscModelUpdatedecimalListInput;
  @Field(() => FloatFieldUpdateOperationsInput, { nullable: true })
  floatField?: FloatFieldUpdateOperationsInput;
  @Field(() => BytesFieldUpdateOperationsInput, { nullable: true })
  bytesField?: BytesFieldUpdateOperationsInput;
  @Field(() => MiscModelUpdatebytesListInput, { nullable: true })
  bytesList?: MiscModelUpdatebytesListInput;
  @Field(() => BigIntFieldUpdateOperationsInput, { nullable: true })
  bigIntField?: BigIntFieldUpdateOperationsInput;
  @Field(() => MiscModelUpdatebigIntListInput, { nullable: true })
  bigIntList?: MiscModelUpdatebigIntListInput;
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  dateTimeField?: DateTimeFieldUpdateOperationsInput;
  @Field(() => MiscModelUpdatedateTimeListInput, { nullable: true })
  dateTimeList?: MiscModelUpdatedateTimeListInput;
}

@InputType()
export class HiddenModelCreateManyInput {
  @Field(() => Int, { nullable: true })
  id?: number;
  @Field(() => Date, { nullable: true })
  createdAt?: Date;
  @Field(() => Date, { nullable: true })
  updatedAt?: Date;
  @Field(() => GraphQLJSON, { nullable: false })
  data: any;
}

@InputType()
export class HiddenModelUpdateManyMutationInput {
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  createdAt?: DateTimeFieldUpdateOperationsInput;
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  updatedAt?: DateTimeFieldUpdateOperationsInput;
  @Field(() => GraphQLJSON, { nullable: true })
  data?: any;
}

@InputType()
export class IntFilter {
  @Field(() => Int, { nullable: true })
  equals?: number;
  @Field(() => [Int], { nullable: true })
  in?: number[];
  @Field(() => [Int], { nullable: true })
  notIn?: number[];
  @Field(() => Int, { nullable: true })
  lt?: number;
  @Field(() => Int, { nullable: true })
  lte?: number;
  @Field(() => Int, { nullable: true })
  gt?: number;
  @Field(() => Int, { nullable: true })
  gte?: number;
  @Field(() => NestedIntFilter, { nullable: true })
  not?: NestedIntFilter;
}

@InputType()
export class DateTimeFilter {
  @Field(() => Date, { nullable: true })
  equals?: Date;
  @Field(() => [Date], { nullable: true })
  in?: Date[];
  @Field(() => [Date], { nullable: true })
  notIn?: Date[];
  @Field(() => Date, { nullable: true })
  lt?: Date;
  @Field(() => Date, { nullable: true })
  lte?: Date;
  @Field(() => Date, { nullable: true })
  gt?: Date;
  @Field(() => Date, { nullable: true })
  gte?: Date;
  @Field(() => NestedDateTimeFilter, { nullable: true })
  not?: NestedDateTimeFilter;
}

@InputType()
export class StringFilter {
  @Field(() => String, { nullable: true })
  equals?: string;
  @Field(() => [String], { nullable: true })
  in?: string[];
  @Field(() => [String], { nullable: true })
  notIn?: string[];
  @Field(() => String, { nullable: true })
  lt?: string;
  @Field(() => String, { nullable: true })
  lte?: string;
  @Field(() => String, { nullable: true })
  gt?: string;
  @Field(() => String, { nullable: true })
  gte?: string;
  @Field(() => String, { nullable: true })
  contains?: string;
  @Field(() => String, { nullable: true })
  startsWith?: string;
  @Field(() => String, { nullable: true })
  endsWith?: string;
  @Field(() => QueryMode, { nullable: true })
  mode?: QueryMode;
  @Field(() => NestedStringFilter, { nullable: true })
  not?: NestedStringFilter;
}

@InputType()
export class StringNullableFilter {
  @Field(() => String, { nullable: true })
  equals?: string;
  @Field(() => [String], { nullable: true })
  in?: string[];
  @Field(() => [String], { nullable: true })
  notIn?: string[];
  @Field(() => String, { nullable: true })
  lt?: string;
  @Field(() => String, { nullable: true })
  lte?: string;
  @Field(() => String, { nullable: true })
  gt?: string;
  @Field(() => String, { nullable: true })
  gte?: string;
  @Field(() => String, { nullable: true })
  contains?: string;
  @Field(() => String, { nullable: true })
  startsWith?: string;
  @Field(() => String, { nullable: true })
  endsWith?: string;
  @Field(() => QueryMode, { nullable: true })
  mode?: QueryMode;
  @Field(() => NestedStringNullableFilter, { nullable: true })
  not?: NestedStringNullableFilter;
}

@InputType()
export class EnumUserRoleFilter {
  @Field(() => UserRole, { nullable: true })
  equals?: UserRole;
  @Field(() => [UserRole], { nullable: true })
  in?: UserRole[];
  @Field(() => [UserRole], { nullable: true })
  notIn?: UserRole[];
  @Field(() => UserRole, { nullable: true })
  not?: UserRole;
}

@InputType()
export class IntNullableFilter {
  @Field(() => Int, { nullable: true })
  equals?: number;
  @Field(() => [Int], { nullable: true })
  in?: number[];
  @Field(() => [Int], { nullable: true })
  notIn?: number[];
  @Field(() => Int, { nullable: true })
  lt?: number;
  @Field(() => Int, { nullable: true })
  lte?: number;
  @Field(() => Int, { nullable: true })
  gt?: number;
  @Field(() => Int, { nullable: true })
  gte?: number;
  @Field(() => NestedIntNullableFilter, { nullable: true })
  not?: NestedIntNullableFilter;
}

@InputType()
export class PostListRelationFilter {
  @Field(() => PostWhereInput, { nullable: true })
  every?: PostWhereInput;
  @Field(() => PostWhereInput, { nullable: true })
  some?: PostWhereInput;
  @Field(() => PostWhereInput, { nullable: true })
  none?: PostWhereInput;
}

@InputType()
export class UserNullableRelationFilter {
  @Field(() => UserWhereInput, { nullable: true })
  is?: UserWhereInput;
  @Field(() => UserWhereInput, { nullable: true })
  isNot?: UserWhereInput;
}

@InputType()
export class UserListRelationFilter {
  @Field(() => UserWhereInput, { nullable: true })
  every?: UserWhereInput;
  @Field(() => UserWhereInput, { nullable: true })
  some?: UserWhereInput;
  @Field(() => UserWhereInput, { nullable: true })
  none?: UserWhereInput;
}

@InputType()
export class TagListRelationFilter {
  @Field(() => TagWhereInput, { nullable: true })
  every?: TagWhereInput;
  @Field(() => TagWhereInput, { nullable: true })
  some?: TagWhereInput;
  @Field(() => TagWhereInput, { nullable: true })
  none?: TagWhereInput;
}

@InputType()
export class ProfileNullableRelationFilter {
  @Field(() => ProfileWhereInput, { nullable: true })
  is?: ProfileWhereInput;
  @Field(() => ProfileWhereInput, { nullable: true })
  isNot?: ProfileWhereInput;
}

@InputType()
export class PostOrderByRelationAggregateInput {
  @Field(() => SortOrder, { nullable: true })
  _count?: SortOrder;
}

@InputType()
export class UserOrderByRelationAggregateInput {
  @Field(() => SortOrder, { nullable: true })
  _count?: SortOrder;
}

@InputType()
export class TagOrderByRelationAggregateInput {
  @Field(() => SortOrder, { nullable: true })
  _count?: SortOrder;
}

@InputType()
export class UserCountOrderByAggregateInput {
  @Field(() => SortOrder, { nullable: true })
  id?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  createdAt?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  updatedAt?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  email?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  name?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  role?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  parentId?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  mappedField?: SortOrder;
}

@InputType()
export class UserAvgOrderByAggregateInput {
  @Field(() => SortOrder, { nullable: true })
  id?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  parentId?: SortOrder;
}

@InputType()
export class UserMaxOrderByAggregateInput {
  @Field(() => SortOrder, { nullable: true })
  id?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  createdAt?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  updatedAt?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  email?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  name?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  role?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  parentId?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  mappedField?: SortOrder;
}

@InputType()
export class UserMinOrderByAggregateInput {
  @Field(() => SortOrder, { nullable: true })
  id?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  createdAt?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  updatedAt?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  email?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  name?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  role?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  parentId?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  mappedField?: SortOrder;
}

@InputType()
export class UserSumOrderByAggregateInput {
  @Field(() => SortOrder, { nullable: true })
  id?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  parentId?: SortOrder;
}

@InputType()
export class IntWithAggregatesFilter {
  @Field(() => Int, { nullable: true })
  equals?: number;
  @Field(() => [Int], { nullable: true })
  in?: number[];
  @Field(() => [Int], { nullable: true })
  notIn?: number[];
  @Field(() => Int, { nullable: true })
  lt?: number;
  @Field(() => Int, { nullable: true })
  lte?: number;
  @Field(() => Int, { nullable: true })
  gt?: number;
  @Field(() => Int, { nullable: true })
  gte?: number;
  @Field(() => NestedIntWithAggregatesFilter, { nullable: true })
  not?: NestedIntWithAggregatesFilter;
  @Field(() => NestedIntFilter, { nullable: true })
  _count?: NestedIntFilter;
  @Field(() => NestedFloatFilter, { nullable: true })
  _avg?: NestedFloatFilter;
  @Field(() => NestedIntFilter, { nullable: true })
  _sum?: NestedIntFilter;
  @Field(() => NestedIntFilter, { nullable: true })
  _min?: NestedIntFilter;
  @Field(() => NestedIntFilter, { nullable: true })
  _max?: NestedIntFilter;
}

@InputType()
export class DateTimeWithAggregatesFilter {
  @Field(() => Date, { nullable: true })
  equals?: Date;
  @Field(() => [Date], { nullable: true })
  in?: Date[];
  @Field(() => [Date], { nullable: true })
  notIn?: Date[];
  @Field(() => Date, { nullable: true })
  lt?: Date;
  @Field(() => Date, { nullable: true })
  lte?: Date;
  @Field(() => Date, { nullable: true })
  gt?: Date;
  @Field(() => Date, { nullable: true })
  gte?: Date;
  @Field(() => NestedDateTimeWithAggregatesFilter, { nullable: true })
  not?: NestedDateTimeWithAggregatesFilter;
  @Field(() => NestedIntFilter, { nullable: true })
  _count?: NestedIntFilter;
  @Field(() => NestedDateTimeFilter, { nullable: true })
  _min?: NestedDateTimeFilter;
  @Field(() => NestedDateTimeFilter, { nullable: true })
  _max?: NestedDateTimeFilter;
}

@InputType()
export class StringWithAggregatesFilter {
  @Field(() => String, { nullable: true })
  equals?: string;
  @Field(() => [String], { nullable: true })
  in?: string[];
  @Field(() => [String], { nullable: true })
  notIn?: string[];
  @Field(() => String, { nullable: true })
  lt?: string;
  @Field(() => String, { nullable: true })
  lte?: string;
  @Field(() => String, { nullable: true })
  gt?: string;
  @Field(() => String, { nullable: true })
  gte?: string;
  @Field(() => String, { nullable: true })
  contains?: string;
  @Field(() => String, { nullable: true })
  startsWith?: string;
  @Field(() => String, { nullable: true })
  endsWith?: string;
  @Field(() => QueryMode, { nullable: true })
  mode?: QueryMode;
  @Field(() => NestedStringWithAggregatesFilter, { nullable: true })
  not?: NestedStringWithAggregatesFilter;
  @Field(() => NestedIntFilter, { nullable: true })
  _count?: NestedIntFilter;
  @Field(() => NestedStringFilter, { nullable: true })
  _min?: NestedStringFilter;
  @Field(() => NestedStringFilter, { nullable: true })
  _max?: NestedStringFilter;
}

@InputType()
export class StringNullableWithAggregatesFilter {
  @Field(() => String, { nullable: true })
  equals?: string;
  @Field(() => [String], { nullable: true })
  in?: string[];
  @Field(() => [String], { nullable: true })
  notIn?: string[];
  @Field(() => String, { nullable: true })
  lt?: string;
  @Field(() => String, { nullable: true })
  lte?: string;
  @Field(() => String, { nullable: true })
  gt?: string;
  @Field(() => String, { nullable: true })
  gte?: string;
  @Field(() => String, { nullable: true })
  contains?: string;
  @Field(() => String, { nullable: true })
  startsWith?: string;
  @Field(() => String, { nullable: true })
  endsWith?: string;
  @Field(() => QueryMode, { nullable: true })
  mode?: QueryMode;
  @Field(() => NestedStringNullableWithAggregatesFilter, { nullable: true })
  not?: NestedStringNullableWithAggregatesFilter;
  @Field(() => NestedIntNullableFilter, { nullable: true })
  _count?: NestedIntNullableFilter;
  @Field(() => NestedStringNullableFilter, { nullable: true })
  _min?: NestedStringNullableFilter;
  @Field(() => NestedStringNullableFilter, { nullable: true })
  _max?: NestedStringNullableFilter;
}

@InputType()
export class EnumUserRoleWithAggregatesFilter {
  @Field(() => UserRole, { nullable: true })
  equals?: UserRole;
  @Field(() => [UserRole], { nullable: true })
  in?: UserRole[];
  @Field(() => [UserRole], { nullable: true })
  notIn?: UserRole[];
  @Field(() => UserRole, { nullable: true })
  not?: UserRole;
  @Field(() => NestedIntFilter, { nullable: true })
  _count?: NestedIntFilter;
  @Field(() => NestedEnumUserRoleFilter, { nullable: true })
  _min?: NestedEnumUserRoleFilter;
  @Field(() => NestedEnumUserRoleFilter, { nullable: true })
  _max?: NestedEnumUserRoleFilter;
}

@InputType()
export class IntNullableWithAggregatesFilter {
  @Field(() => Int, { nullable: true })
  equals?: number;
  @Field(() => [Int], { nullable: true })
  in?: number[];
  @Field(() => [Int], { nullable: true })
  notIn?: number[];
  @Field(() => Int, { nullable: true })
  lt?: number;
  @Field(() => Int, { nullable: true })
  lte?: number;
  @Field(() => Int, { nullable: true })
  gt?: number;
  @Field(() => Int, { nullable: true })
  gte?: number;
  @Field(() => NestedIntNullableWithAggregatesFilter, { nullable: true })
  not?: NestedIntNullableWithAggregatesFilter;
  @Field(() => NestedIntNullableFilter, { nullable: true })
  _count?: NestedIntNullableFilter;
  @Field(() => NestedFloatNullableFilter, { nullable: true })
  _avg?: NestedFloatNullableFilter;
  @Field(() => NestedIntNullableFilter, { nullable: true })
  _sum?: NestedIntNullableFilter;
  @Field(() => NestedIntNullableFilter, { nullable: true })
  _min?: NestedIntNullableFilter;
  @Field(() => NestedIntNullableFilter, { nullable: true })
  _max?: NestedIntNullableFilter;
}

@InputType()
export class UserRelationFilter {
  @Field(() => UserWhereInput, { nullable: true })
  is?: UserWhereInput;
  @Field(() => UserWhereInput, { nullable: true })
  isNot?: UserWhereInput;
}

@InputType()
export class ProfileCountOrderByAggregateInput {
  @Field(() => SortOrder, { nullable: true })
  id?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  createdAt?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  updatedAt?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  bio?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  userId?: SortOrder;
}

@InputType()
export class ProfileAvgOrderByAggregateInput {
  @Field(() => SortOrder, { nullable: true })
  id?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  userId?: SortOrder;
}

@InputType()
export class ProfileMaxOrderByAggregateInput {
  @Field(() => SortOrder, { nullable: true })
  id?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  createdAt?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  updatedAt?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  bio?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  userId?: SortOrder;
}

@InputType()
export class ProfileMinOrderByAggregateInput {
  @Field(() => SortOrder, { nullable: true })
  id?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  createdAt?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  updatedAt?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  bio?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  userId?: SortOrder;
}

@InputType()
export class ProfileSumOrderByAggregateInput {
  @Field(() => SortOrder, { nullable: true })
  id?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  userId?: SortOrder;
}

@InputType()
export class BoolFilter {
  @Field(() => Boolean, { nullable: true })
  equals?: boolean;
  @Field(() => NestedBoolFilter, { nullable: true })
  not?: NestedBoolFilter;
}

@InputType()
export class EnumPostKindFilter {
  @Field(() => PostKind, { nullable: true })
  equals?: PostKind;
  @Field(() => [PostKind], { nullable: true })
  in?: PostKind[];
  @Field(() => [PostKind], { nullable: true })
  notIn?: PostKind[];
  @Field(() => PostKind, { nullable: true })
  not?: PostKind;
}

@InputType()
export class CategoryListRelationFilter {
  @Field(() => CategoryWhereInput, { nullable: true })
  every?: CategoryWhereInput;
  @Field(() => CategoryWhereInput, { nullable: true })
  some?: CategoryWhereInput;
  @Field(() => CategoryWhereInput, { nullable: true })
  none?: CategoryWhereInput;
}

@InputType()
export class CategoryOrderByRelationAggregateInput {
  @Field(() => SortOrder, { nullable: true })
  _count?: SortOrder;
}

@InputType()
export class PostCountOrderByAggregateInput {
  @Field(() => SortOrder, { nullable: true })
  id?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  createdAt?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  updatedAt?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  title?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  content?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  published?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  authorId?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  anotherAuthorId?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  postKind?: SortOrder;
}

@InputType()
export class PostAvgOrderByAggregateInput {
  @Field(() => SortOrder, { nullable: true })
  id?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  authorId?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  anotherAuthorId?: SortOrder;
}

@InputType()
export class PostMaxOrderByAggregateInput {
  @Field(() => SortOrder, { nullable: true })
  id?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  createdAt?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  updatedAt?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  title?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  content?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  published?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  authorId?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  anotherAuthorId?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  postKind?: SortOrder;
}

@InputType()
export class PostMinOrderByAggregateInput {
  @Field(() => SortOrder, { nullable: true })
  id?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  createdAt?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  updatedAt?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  title?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  content?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  published?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  authorId?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  anotherAuthorId?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  postKind?: SortOrder;
}

@InputType()
export class PostSumOrderByAggregateInput {
  @Field(() => SortOrder, { nullable: true })
  id?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  authorId?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  anotherAuthorId?: SortOrder;
}

@InputType()
export class BoolWithAggregatesFilter {
  @Field(() => Boolean, { nullable: true })
  equals?: boolean;
  @Field(() => NestedBoolWithAggregatesFilter, { nullable: true })
  not?: NestedBoolWithAggregatesFilter;
  @Field(() => NestedIntFilter, { nullable: true })
  _count?: NestedIntFilter;
  @Field(() => NestedBoolFilter, { nullable: true })
  _min?: NestedBoolFilter;
  @Field(() => NestedBoolFilter, { nullable: true })
  _max?: NestedBoolFilter;
}

@InputType()
export class EnumPostKindWithAggregatesFilter {
  @Field(() => PostKind, { nullable: true })
  equals?: PostKind;
  @Field(() => [PostKind], { nullable: true })
  in?: PostKind[];
  @Field(() => [PostKind], { nullable: true })
  notIn?: PostKind[];
  @Field(() => PostKind, { nullable: true })
  not?: PostKind;
  @Field(() => NestedIntFilter, { nullable: true })
  _count?: NestedIntFilter;
  @Field(() => NestedEnumPostKindFilter, { nullable: true })
  _min?: NestedEnumPostKindFilter;
  @Field(() => NestedEnumPostKindFilter, { nullable: true })
  _max?: NestedEnumPostKindFilter;
}

@InputType()
export class TagCountOrderByAggregateInput {
  @Field(() => SortOrder, { nullable: true })
  key?: SortOrder;
}

@InputType()
export class TagMaxOrderByAggregateInput {
  @Field(() => SortOrder, { nullable: true })
  key?: SortOrder;
}

@InputType()
export class TagMinOrderByAggregateInput {
  @Field(() => SortOrder, { nullable: true })
  key?: SortOrder;
}

@InputType()
export class CategoryMetadataNullableRelationFilter {
  @Field(() => CategoryMetadataWhereInput, { nullable: true })
  is?: CategoryMetadataWhereInput;
  @Field(() => CategoryMetadataWhereInput, { nullable: true })
  isNot?: CategoryMetadataWhereInput;
}

@InputType()
export class CategoryCountOrderByAggregateInput {
  @Field(() => SortOrder, { nullable: true })
  id?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  createdAt?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  updatedAt?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  name?: SortOrder;
}

@InputType()
export class CategoryAvgOrderByAggregateInput {
  @Field(() => SortOrder, { nullable: true })
  id?: SortOrder;
}

@InputType()
export class CategoryMaxOrderByAggregateInput {
  @Field(() => SortOrder, { nullable: true })
  id?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  createdAt?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  updatedAt?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  name?: SortOrder;
}

@InputType()
export class CategoryMinOrderByAggregateInput {
  @Field(() => SortOrder, { nullable: true })
  id?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  createdAt?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  updatedAt?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  name?: SortOrder;
}

@InputType()
export class CategorySumOrderByAggregateInput {
  @Field(() => SortOrder, { nullable: true })
  id?: SortOrder;
}

@InputType()
export class JsonNullableListFilter {
  @Field(() => [GraphQLJSON], { nullable: true })
  equals?: any[];
  @Field(() => GraphQLJSON, { nullable: true })
  has?: any;
  @Field(() => [GraphQLJSON], { nullable: true })
  hasEvery?: any[];
  @Field(() => [GraphQLJSON], { nullable: true })
  hasSome?: any[];
  @Field(() => Boolean, { nullable: true })
  isEmpty?: boolean;
}

@InputType()
export class CategoryRelationFilter {
  @Field(() => CategoryWhereInput, { nullable: true })
  is?: CategoryWhereInput;
  @Field(() => CategoryWhereInput, { nullable: true })
  isNot?: CategoryWhereInput;
}

@InputType()
export class CategoryMetadataCountOrderByAggregateInput {
  @Field(() => SortOrder, { nullable: true })
  id?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  createdAt?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  updatedAt?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  categoryId?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  metadata?: SortOrder;
}

@InputType()
export class CategoryMetadataAvgOrderByAggregateInput {
  @Field(() => SortOrder, { nullable: true })
  id?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  categoryId?: SortOrder;
}

@InputType()
export class CategoryMetadataMaxOrderByAggregateInput {
  @Field(() => SortOrder, { nullable: true })
  id?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  createdAt?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  updatedAt?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  categoryId?: SortOrder;
}

@InputType()
export class CategoryMetadataMinOrderByAggregateInput {
  @Field(() => SortOrder, { nullable: true })
  id?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  createdAt?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  updatedAt?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  categoryId?: SortOrder;
}

@InputType()
export class CategoryMetadataSumOrderByAggregateInput {
  @Field(() => SortOrder, { nullable: true })
  id?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  categoryId?: SortOrder;
}

@InputType()
export class JsonFilter {
  @Field(() => GraphQLJSON, { nullable: true })
  equals?: any;
  @Field(() => [String], { nullable: true })
  path?: string[];
  @Field(() => String, { nullable: true })
  string_contains?: string;
  @Field(() => String, { nullable: true })
  string_starts_with?: string;
  @Field(() => String, { nullable: true })
  string_ends_with?: string;
  @Field(() => GraphQLJSON, { nullable: true })
  array_contains?: any;
  @Field(() => GraphQLJSON, { nullable: true })
  array_starts_with?: any;
  @Field(() => GraphQLJSON, { nullable: true })
  array_ends_with?: any;
  @Field(() => GraphQLJSON, { nullable: true })
  lt?: any;
  @Field(() => GraphQLJSON, { nullable: true })
  lte?: any;
  @Field(() => GraphQLJSON, { nullable: true })
  gt?: any;
  @Field(() => GraphQLJSON, { nullable: true })
  gte?: any;
  @Field(() => GraphQLJSON, { nullable: true })
  not?: any;
}

@InputType()
export class StringNullableListFilter {
  @Field(() => [String], { nullable: true })
  equals?: string[];
  @Field(() => String, { nullable: true })
  has?: string;
  @Field(() => [String], { nullable: true })
  hasEvery?: string[];
  @Field(() => [String], { nullable: true })
  hasSome?: string[];
  @Field(() => Boolean, { nullable: true })
  isEmpty?: boolean;
}

@InputType()
export class DecimalFilter {
  @Field(() => GraphQLHexadecimal, { nullable: true })
  equals?: string;
  @Field(() => [GraphQLHexadecimal], { nullable: true })
  in?: string[];
  @Field(() => [GraphQLHexadecimal], { nullable: true })
  notIn?: string[];
  @Field(() => GraphQLHexadecimal, { nullable: true })
  lt?: string;
  @Field(() => GraphQLHexadecimal, { nullable: true })
  lte?: string;
  @Field(() => GraphQLHexadecimal, { nullable: true })
  gt?: string;
  @Field(() => GraphQLHexadecimal, { nullable: true })
  gte?: string;
  @Field(() => NestedDecimalFilter, { nullable: true })
  not?: NestedDecimalFilter;
}

@InputType()
export class DecimalNullableListFilter {
  @Field(() => [GraphQLHexadecimal], { nullable: true })
  equals?: string[];
  @Field(() => GraphQLHexadecimal, { nullable: true })
  has?: string;
  @Field(() => [GraphQLHexadecimal], { nullable: true })
  hasEvery?: string[];
  @Field(() => [GraphQLHexadecimal], { nullable: true })
  hasSome?: string[];
  @Field(() => Boolean, { nullable: true })
  isEmpty?: boolean;
}

@InputType()
export class FloatFilter {
  @Field(() => Float, { nullable: true })
  equals?: number;
  @Field(() => [Float], { nullable: true })
  in?: number[];
  @Field(() => [Float], { nullable: true })
  notIn?: number[];
  @Field(() => Float, { nullable: true })
  lt?: number;
  @Field(() => Float, { nullable: true })
  lte?: number;
  @Field(() => Float, { nullable: true })
  gt?: number;
  @Field(() => Float, { nullable: true })
  gte?: number;
  @Field(() => NestedFloatFilter, { nullable: true })
  not?: NestedFloatFilter;
}

@InputType()
export class BytesFilter {
  @Field(() => GraphQLByte, { nullable: true })
  equals?: Buffer;
  @Field(() => [GraphQLByte], { nullable: true })
  in?: Buffer[];
  @Field(() => [GraphQLByte], { nullable: true })
  notIn?: Buffer[];
  @Field(() => NestedBytesFilter, { nullable: true })
  not?: NestedBytesFilter;
}

@InputType()
export class BytesNullableListFilter {
  @Field(() => [GraphQLByte], { nullable: true })
  equals?: Buffer[];
  @Field(() => GraphQLByte, { nullable: true })
  has?: Buffer;
  @Field(() => [GraphQLByte], { nullable: true })
  hasEvery?: Buffer[];
  @Field(() => [GraphQLByte], { nullable: true })
  hasSome?: Buffer[];
  @Field(() => Boolean, { nullable: true })
  isEmpty?: boolean;
}

@InputType()
export class BigIntFilter {
  @Field(() => GraphQLBigInt, { nullable: true })
  equals?: bigint;
  @Field(() => [GraphQLBigInt], { nullable: true })
  in?: bigint[];
  @Field(() => [GraphQLBigInt], { nullable: true })
  notIn?: bigint[];
  @Field(() => GraphQLBigInt, { nullable: true })
  lt?: bigint;
  @Field(() => GraphQLBigInt, { nullable: true })
  lte?: bigint;
  @Field(() => GraphQLBigInt, { nullable: true })
  gt?: bigint;
  @Field(() => GraphQLBigInt, { nullable: true })
  gte?: bigint;
  @Field(() => NestedBigIntFilter, { nullable: true })
  not?: NestedBigIntFilter;
}

@InputType()
export class BigIntNullableListFilter {
  @Field(() => [GraphQLBigInt], { nullable: true })
  equals?: bigint[];
  @Field(() => GraphQLBigInt, { nullable: true })
  has?: bigint;
  @Field(() => [GraphQLBigInt], { nullable: true })
  hasEvery?: bigint[];
  @Field(() => [GraphQLBigInt], { nullable: true })
  hasSome?: bigint[];
  @Field(() => Boolean, { nullable: true })
  isEmpty?: boolean;
}

@InputType()
export class DateTimeNullableListFilter {
  @Field(() => [Date], { nullable: true })
  equals?: Date[];
  @Field(() => Date, { nullable: true })
  has?: Date;
  @Field(() => [Date], { nullable: true })
  hasEvery?: Date[];
  @Field(() => [Date], { nullable: true })
  hasSome?: Date[];
  @Field(() => Boolean, { nullable: true })
  isEmpty?: boolean;
}

@InputType()
export class MiscModelCountOrderByAggregateInput {
  @Field(() => SortOrder, { nullable: true })
  id?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  createdAt?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  updatedAt?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  name?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  jsonField?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  jsonList?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  stringList?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  decimalField?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  decimalList?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  floatField?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  bytesField?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  bytesList?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  bigIntField?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  bigIntList?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  dateTimeField?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  dateTimeList?: SortOrder;
}

@InputType()
export class MiscModelAvgOrderByAggregateInput {
  @Field(() => SortOrder, { nullable: true })
  id?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  decimalField?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  decimalList?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  floatField?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  bigIntField?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  bigIntList?: SortOrder;
}

@InputType()
export class MiscModelMaxOrderByAggregateInput {
  @Field(() => SortOrder, { nullable: true })
  id?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  createdAt?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  updatedAt?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  name?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  decimalField?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  floatField?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  bytesField?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  bigIntField?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  dateTimeField?: SortOrder;
}

@InputType()
export class MiscModelMinOrderByAggregateInput {
  @Field(() => SortOrder, { nullable: true })
  id?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  createdAt?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  updatedAt?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  name?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  decimalField?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  floatField?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  bytesField?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  bigIntField?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  dateTimeField?: SortOrder;
}

@InputType()
export class MiscModelSumOrderByAggregateInput {
  @Field(() => SortOrder, { nullable: true })
  id?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  decimalField?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  decimalList?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  floatField?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  bigIntField?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  bigIntList?: SortOrder;
}

@InputType()
export class JsonWithAggregatesFilter {
  @Field(() => GraphQLJSON, { nullable: true })
  equals?: any;
  @Field(() => [String], { nullable: true })
  path?: string[];
  @Field(() => String, { nullable: true })
  string_contains?: string;
  @Field(() => String, { nullable: true })
  string_starts_with?: string;
  @Field(() => String, { nullable: true })
  string_ends_with?: string;
  @Field(() => GraphQLJSON, { nullable: true })
  array_contains?: any;
  @Field(() => GraphQLJSON, { nullable: true })
  array_starts_with?: any;
  @Field(() => GraphQLJSON, { nullable: true })
  array_ends_with?: any;
  @Field(() => GraphQLJSON, { nullable: true })
  lt?: any;
  @Field(() => GraphQLJSON, { nullable: true })
  lte?: any;
  @Field(() => GraphQLJSON, { nullable: true })
  gt?: any;
  @Field(() => GraphQLJSON, { nullable: true })
  gte?: any;
  @Field(() => GraphQLJSON, { nullable: true })
  not?: any;
  @Field(() => NestedIntFilter, { nullable: true })
  _count?: NestedIntFilter;
  @Field(() => NestedJsonFilter, { nullable: true })
  _min?: NestedJsonFilter;
  @Field(() => NestedJsonFilter, { nullable: true })
  _max?: NestedJsonFilter;
}

@InputType()
export class DecimalWithAggregatesFilter {
  @Field(() => GraphQLHexadecimal, { nullable: true })
  equals?: string;
  @Field(() => [GraphQLHexadecimal], { nullable: true })
  in?: string[];
  @Field(() => [GraphQLHexadecimal], { nullable: true })
  notIn?: string[];
  @Field(() => GraphQLHexadecimal, { nullable: true })
  lt?: string;
  @Field(() => GraphQLHexadecimal, { nullable: true })
  lte?: string;
  @Field(() => GraphQLHexadecimal, { nullable: true })
  gt?: string;
  @Field(() => GraphQLHexadecimal, { nullable: true })
  gte?: string;
  @Field(() => NestedDecimalWithAggregatesFilter, { nullable: true })
  not?: NestedDecimalWithAggregatesFilter;
  @Field(() => NestedIntFilter, { nullable: true })
  _count?: NestedIntFilter;
  @Field(() => NestedDecimalFilter, { nullable: true })
  _avg?: NestedDecimalFilter;
  @Field(() => NestedDecimalFilter, { nullable: true })
  _sum?: NestedDecimalFilter;
  @Field(() => NestedDecimalFilter, { nullable: true })
  _min?: NestedDecimalFilter;
  @Field(() => NestedDecimalFilter, { nullable: true })
  _max?: NestedDecimalFilter;
}

@InputType()
export class FloatWithAggregatesFilter {
  @Field(() => Float, { nullable: true })
  equals?: number;
  @Field(() => [Float], { nullable: true })
  in?: number[];
  @Field(() => [Float], { nullable: true })
  notIn?: number[];
  @Field(() => Float, { nullable: true })
  lt?: number;
  @Field(() => Float, { nullable: true })
  lte?: number;
  @Field(() => Float, { nullable: true })
  gt?: number;
  @Field(() => Float, { nullable: true })
  gte?: number;
  @Field(() => NestedFloatWithAggregatesFilter, { nullable: true })
  not?: NestedFloatWithAggregatesFilter;
  @Field(() => NestedIntFilter, { nullable: true })
  _count?: NestedIntFilter;
  @Field(() => NestedFloatFilter, { nullable: true })
  _avg?: NestedFloatFilter;
  @Field(() => NestedFloatFilter, { nullable: true })
  _sum?: NestedFloatFilter;
  @Field(() => NestedFloatFilter, { nullable: true })
  _min?: NestedFloatFilter;
  @Field(() => NestedFloatFilter, { nullable: true })
  _max?: NestedFloatFilter;
}

@InputType()
export class BytesWithAggregatesFilter {
  @Field(() => GraphQLByte, { nullable: true })
  equals?: Buffer;
  @Field(() => [GraphQLByte], { nullable: true })
  in?: Buffer[];
  @Field(() => [GraphQLByte], { nullable: true })
  notIn?: Buffer[];
  @Field(() => NestedBytesWithAggregatesFilter, { nullable: true })
  not?: NestedBytesWithAggregatesFilter;
  @Field(() => NestedIntFilter, { nullable: true })
  _count?: NestedIntFilter;
  @Field(() => NestedBytesFilter, { nullable: true })
  _min?: NestedBytesFilter;
  @Field(() => NestedBytesFilter, { nullable: true })
  _max?: NestedBytesFilter;
}

@InputType()
export class BigIntWithAggregatesFilter {
  @Field(() => GraphQLBigInt, { nullable: true })
  equals?: bigint;
  @Field(() => [GraphQLBigInt], { nullable: true })
  in?: bigint[];
  @Field(() => [GraphQLBigInt], { nullable: true })
  notIn?: bigint[];
  @Field(() => GraphQLBigInt, { nullable: true })
  lt?: bigint;
  @Field(() => GraphQLBigInt, { nullable: true })
  lte?: bigint;
  @Field(() => GraphQLBigInt, { nullable: true })
  gt?: bigint;
  @Field(() => GraphQLBigInt, { nullable: true })
  gte?: bigint;
  @Field(() => NestedBigIntWithAggregatesFilter, { nullable: true })
  not?: NestedBigIntWithAggregatesFilter;
  @Field(() => NestedIntFilter, { nullable: true })
  _count?: NestedIntFilter;
  @Field(() => NestedFloatFilter, { nullable: true })
  _avg?: NestedFloatFilter;
  @Field(() => NestedBigIntFilter, { nullable: true })
  _sum?: NestedBigIntFilter;
  @Field(() => NestedBigIntFilter, { nullable: true })
  _min?: NestedBigIntFilter;
  @Field(() => NestedBigIntFilter, { nullable: true })
  _max?: NestedBigIntFilter;
}

@InputType()
export class HiddenModelCountOrderByAggregateInput {
  @Field(() => SortOrder, { nullable: true })
  id?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  createdAt?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  updatedAt?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  data?: SortOrder;
}

@InputType()
export class HiddenModelAvgOrderByAggregateInput {
  @Field(() => SortOrder, { nullable: true })
  id?: SortOrder;
}

@InputType()
export class HiddenModelMaxOrderByAggregateInput {
  @Field(() => SortOrder, { nullable: true })
  id?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  createdAt?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  updatedAt?: SortOrder;
}

@InputType()
export class HiddenModelMinOrderByAggregateInput {
  @Field(() => SortOrder, { nullable: true })
  id?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  createdAt?: SortOrder;
  @Field(() => SortOrder, { nullable: true })
  updatedAt?: SortOrder;
}

@InputType()
export class HiddenModelSumOrderByAggregateInput {
  @Field(() => SortOrder, { nullable: true })
  id?: SortOrder;
}

@InputType()
export class PostCreateNestedManyWithoutAuthorInput {
  @Field(() => [PostCreateWithoutAuthorInput], { nullable: true })
  create?: PostCreateWithoutAuthorInput[];
  @Field(() => [PostCreateOrConnectWithoutAuthorInput], { nullable: true })
  connectOrCreate?: PostCreateOrConnectWithoutAuthorInput[];
  @Field(() => PostCreateManyAuthorInputEnvelope, { nullable: true })
  createMany?: PostCreateManyAuthorInputEnvelope;
  @Field(() => [PostWhereUniqueInput], { nullable: true })
  connect?: PostWhereUniqueInput[];
}

@InputType()
export class UserCreateNestedOneWithoutChildrenInput {
  @Field(() => UserCreateWithoutChildrenInput, { nullable: true })
  create?: UserCreateWithoutChildrenInput;
  @Field(() => UserCreateOrConnectWithoutChildrenInput, { nullable: true })
  connectOrCreate?: UserCreateOrConnectWithoutChildrenInput;
  @Field(() => UserWhereUniqueInput, { nullable: true })
  connect?: UserWhereUniqueInput;
}

@InputType()
export class UserCreateNestedManyWithoutParentInput {
  @Field(() => [UserCreateWithoutParentInput], { nullable: true })
  create?: UserCreateWithoutParentInput[];
  @Field(() => [UserCreateOrConnectWithoutParentInput], { nullable: true })
  connectOrCreate?: UserCreateOrConnectWithoutParentInput[];
  @Field(() => UserCreateManyParentInputEnvelope, { nullable: true })
  createMany?: UserCreateManyParentInputEnvelope;
  @Field(() => [UserWhereUniqueInput], { nullable: true })
  connect?: UserWhereUniqueInput[];
}

@InputType()
export class PostCreateNestedManyWithoutAnotherAuthorInput {
  @Field(() => [PostCreateWithoutAnotherAuthorInput], { nullable: true })
  create?: PostCreateWithoutAnotherAuthorInput[];
  @Field(() => [PostCreateOrConnectWithoutAnotherAuthorInput], {
    nullable: true,
  })
  connectOrCreate?: PostCreateOrConnectWithoutAnotherAuthorInput[];
  @Field(() => PostCreateManyAnotherAuthorInputEnvelope, { nullable: true })
  createMany?: PostCreateManyAnotherAuthorInputEnvelope;
  @Field(() => [PostWhereUniqueInput], { nullable: true })
  connect?: PostWhereUniqueInput[];
}

@InputType()
export class TagCreateNestedManyWithoutUsersInput {
  @Field(() => [TagCreateWithoutUsersInput], { nullable: true })
  create?: TagCreateWithoutUsersInput[];
  @Field(() => [TagCreateOrConnectWithoutUsersInput], { nullable: true })
  connectOrCreate?: TagCreateOrConnectWithoutUsersInput[];
  @Field(() => [TagWhereUniqueInput], { nullable: true })
  connect?: TagWhereUniqueInput[];
}

@InputType()
export class ProfileCreateNestedOneWithoutUserInput {
  @Field(() => ProfileCreateWithoutUserInput, { nullable: true })
  create?: ProfileCreateWithoutUserInput;
  @Field(() => ProfileCreateOrConnectWithoutUserInput, { nullable: true })
  connectOrCreate?: ProfileCreateOrConnectWithoutUserInput;
  @Field(() => ProfileWhereUniqueInput, { nullable: true })
  connect?: ProfileWhereUniqueInput;
}

@InputType()
export class PostUncheckedCreateNestedManyWithoutAuthorInput {
  @Field(() => [PostCreateWithoutAuthorInput], { nullable: true })
  create?: PostCreateWithoutAuthorInput[];
  @Field(() => [PostCreateOrConnectWithoutAuthorInput], { nullable: true })
  connectOrCreate?: PostCreateOrConnectWithoutAuthorInput[];
  @Field(() => PostCreateManyAuthorInputEnvelope, { nullable: true })
  createMany?: PostCreateManyAuthorInputEnvelope;
  @Field(() => [PostWhereUniqueInput], { nullable: true })
  connect?: PostWhereUniqueInput[];
}

@InputType()
export class UserUncheckedCreateNestedManyWithoutParentInput {
  @Field(() => [UserCreateWithoutParentInput], { nullable: true })
  create?: UserCreateWithoutParentInput[];
  @Field(() => [UserCreateOrConnectWithoutParentInput], { nullable: true })
  connectOrCreate?: UserCreateOrConnectWithoutParentInput[];
  @Field(() => UserCreateManyParentInputEnvelope, { nullable: true })
  createMany?: UserCreateManyParentInputEnvelope;
  @Field(() => [UserWhereUniqueInput], { nullable: true })
  connect?: UserWhereUniqueInput[];
}

@InputType()
export class PostUncheckedCreateNestedManyWithoutAnotherAuthorInput {
  @Field(() => [PostCreateWithoutAnotherAuthorInput], { nullable: true })
  create?: PostCreateWithoutAnotherAuthorInput[];
  @Field(() => [PostCreateOrConnectWithoutAnotherAuthorInput], {
    nullable: true,
  })
  connectOrCreate?: PostCreateOrConnectWithoutAnotherAuthorInput[];
  @Field(() => PostCreateManyAnotherAuthorInputEnvelope, { nullable: true })
  createMany?: PostCreateManyAnotherAuthorInputEnvelope;
  @Field(() => [PostWhereUniqueInput], { nullable: true })
  connect?: PostWhereUniqueInput[];
}

@InputType()
export class TagUncheckedCreateNestedManyWithoutUsersInput {
  @Field(() => [TagCreateWithoutUsersInput], { nullable: true })
  create?: TagCreateWithoutUsersInput[];
  @Field(() => [TagCreateOrConnectWithoutUsersInput], { nullable: true })
  connectOrCreate?: TagCreateOrConnectWithoutUsersInput[];
  @Field(() => [TagWhereUniqueInput], { nullable: true })
  connect?: TagWhereUniqueInput[];
}

@InputType()
export class ProfileUncheckedCreateNestedOneWithoutUserInput {
  @Field(() => ProfileCreateWithoutUserInput, { nullable: true })
  create?: ProfileCreateWithoutUserInput;
  @Field(() => ProfileCreateOrConnectWithoutUserInput, { nullable: true })
  connectOrCreate?: ProfileCreateOrConnectWithoutUserInput;
  @Field(() => ProfileWhereUniqueInput, { nullable: true })
  connect?: ProfileWhereUniqueInput;
}

@InputType()
export class DateTimeFieldUpdateOperationsInput {
  @Field(() => Date, { nullable: true })
  set?: Date;
}

@InputType()
export class StringFieldUpdateOperationsInput {
  @Field(() => String, { nullable: true })
  set?: string;
}

@InputType()
export class NullableStringFieldUpdateOperationsInput {
  @Field(() => String, { nullable: true })
  set?: string;
}

@InputType()
export class PostUpdateManyWithoutAuthorNestedInput {
  @Field(() => [PostCreateWithoutAuthorInput], { nullable: true })
  create?: PostCreateWithoutAuthorInput[];
  @Field(() => [PostCreateOrConnectWithoutAuthorInput], { nullable: true })
  connectOrCreate?: PostCreateOrConnectWithoutAuthorInput[];
  @Field(() => [PostUpsertWithWhereUniqueWithoutAuthorInput], {
    nullable: true,
  })
  upsert?: PostUpsertWithWhereUniqueWithoutAuthorInput[];
  @Field(() => PostCreateManyAuthorInputEnvelope, { nullable: true })
  createMany?: PostCreateManyAuthorInputEnvelope;
  @Field(() => [PostWhereUniqueInput], { nullable: true })
  set?: PostWhereUniqueInput[];
  @Field(() => [PostWhereUniqueInput], { nullable: true })
  disconnect?: PostWhereUniqueInput[];
  @Field(() => [PostWhereUniqueInput], { nullable: true })
  delete?: PostWhereUniqueInput[];
  @Field(() => [PostWhereUniqueInput], { nullable: true })
  connect?: PostWhereUniqueInput[];
  @Field(() => [PostUpdateWithWhereUniqueWithoutAuthorInput], {
    nullable: true,
  })
  update?: PostUpdateWithWhereUniqueWithoutAuthorInput[];
  @Field(() => [PostUpdateManyWithWhereWithoutAuthorInput], { nullable: true })
  updateMany?: PostUpdateManyWithWhereWithoutAuthorInput[];
  @Field(() => [PostScalarWhereInput], { nullable: true })
  deleteMany?: PostScalarWhereInput[];
}

@InputType()
export class UserUpdateOneWithoutChildrenNestedInput {
  @Field(() => UserCreateWithoutChildrenInput, { nullable: true })
  create?: UserCreateWithoutChildrenInput;
  @Field(() => UserCreateOrConnectWithoutChildrenInput, { nullable: true })
  connectOrCreate?: UserCreateOrConnectWithoutChildrenInput;
  @Field(() => UserUpsertWithoutChildrenInput, { nullable: true })
  upsert?: UserUpsertWithoutChildrenInput;
  @Field(() => UserWhereInput, { nullable: true })
  disconnect?: UserWhereInput;
  @Field(() => UserWhereInput, { nullable: true })
  delete?: UserWhereInput;
  @Field(() => UserWhereUniqueInput, { nullable: true })
  connect?: UserWhereUniqueInput;
  @Field(() => UserUpdateToOneWithWhereWithoutChildrenInput, { nullable: true })
  update?: UserUpdateToOneWithWhereWithoutChildrenInput;
}

@InputType()
export class UserUpdateManyWithoutParentNestedInput {
  @Field(() => [UserCreateWithoutParentInput], { nullable: true })
  create?: UserCreateWithoutParentInput[];
  @Field(() => [UserCreateOrConnectWithoutParentInput], { nullable: true })
  connectOrCreate?: UserCreateOrConnectWithoutParentInput[];
  @Field(() => [UserUpsertWithWhereUniqueWithoutParentInput], {
    nullable: true,
  })
  upsert?: UserUpsertWithWhereUniqueWithoutParentInput[];
  @Field(() => UserCreateManyParentInputEnvelope, { nullable: true })
  createMany?: UserCreateManyParentInputEnvelope;
  @Field(() => [UserWhereUniqueInput], { nullable: true })
  set?: UserWhereUniqueInput[];
  @Field(() => [UserWhereUniqueInput], { nullable: true })
  disconnect?: UserWhereUniqueInput[];
  @Field(() => [UserWhereUniqueInput], { nullable: true })
  delete?: UserWhereUniqueInput[];
  @Field(() => [UserWhereUniqueInput], { nullable: true })
  connect?: UserWhereUniqueInput[];
  @Field(() => [UserUpdateWithWhereUniqueWithoutParentInput], {
    nullable: true,
  })
  update?: UserUpdateWithWhereUniqueWithoutParentInput[];
  @Field(() => [UserUpdateManyWithWhereWithoutParentInput], { nullable: true })
  updateMany?: UserUpdateManyWithWhereWithoutParentInput[];
  @Field(() => [UserScalarWhereInput], { nullable: true })
  deleteMany?: UserScalarWhereInput[];
}

@InputType()
export class PostUpdateManyWithoutAnotherAuthorNestedInput {
  @Field(() => [PostCreateWithoutAnotherAuthorInput], { nullable: true })
  create?: PostCreateWithoutAnotherAuthorInput[];
  @Field(() => [PostCreateOrConnectWithoutAnotherAuthorInput], {
    nullable: true,
  })
  connectOrCreate?: PostCreateOrConnectWithoutAnotherAuthorInput[];
  @Field(() => [PostUpsertWithWhereUniqueWithoutAnotherAuthorInput], {
    nullable: true,
  })
  upsert?: PostUpsertWithWhereUniqueWithoutAnotherAuthorInput[];
  @Field(() => PostCreateManyAnotherAuthorInputEnvelope, { nullable: true })
  createMany?: PostCreateManyAnotherAuthorInputEnvelope;
  @Field(() => [PostWhereUniqueInput], { nullable: true })
  set?: PostWhereUniqueInput[];
  @Field(() => [PostWhereUniqueInput], { nullable: true })
  disconnect?: PostWhereUniqueInput[];
  @Field(() => [PostWhereUniqueInput], { nullable: true })
  delete?: PostWhereUniqueInput[];
  @Field(() => [PostWhereUniqueInput], { nullable: true })
  connect?: PostWhereUniqueInput[];
  @Field(() => [PostUpdateWithWhereUniqueWithoutAnotherAuthorInput], {
    nullable: true,
  })
  update?: PostUpdateWithWhereUniqueWithoutAnotherAuthorInput[];
  @Field(() => [PostUpdateManyWithWhereWithoutAnotherAuthorInput], {
    nullable: true,
  })
  updateMany?: PostUpdateManyWithWhereWithoutAnotherAuthorInput[];
  @Field(() => [PostScalarWhereInput], { nullable: true })
  deleteMany?: PostScalarWhereInput[];
}

@InputType()
export class TagUpdateManyWithoutUsersNestedInput {
  @Field(() => [TagCreateWithoutUsersInput], { nullable: true })
  create?: TagCreateWithoutUsersInput[];
  @Field(() => [TagCreateOrConnectWithoutUsersInput], { nullable: true })
  connectOrCreate?: TagCreateOrConnectWithoutUsersInput[];
  @Field(() => [TagUpsertWithWhereUniqueWithoutUsersInput], { nullable: true })
  upsert?: TagUpsertWithWhereUniqueWithoutUsersInput[];
  @Field(() => [TagWhereUniqueInput], { nullable: true })
  set?: TagWhereUniqueInput[];
  @Field(() => [TagWhereUniqueInput], { nullable: true })
  disconnect?: TagWhereUniqueInput[];
  @Field(() => [TagWhereUniqueInput], { nullable: true })
  delete?: TagWhereUniqueInput[];
  @Field(() => [TagWhereUniqueInput], { nullable: true })
  connect?: TagWhereUniqueInput[];
  @Field(() => [TagUpdateWithWhereUniqueWithoutUsersInput], { nullable: true })
  update?: TagUpdateWithWhereUniqueWithoutUsersInput[];
  @Field(() => [TagUpdateManyWithWhereWithoutUsersInput], { nullable: true })
  updateMany?: TagUpdateManyWithWhereWithoutUsersInput[];
  @Field(() => [TagScalarWhereInput], { nullable: true })
  deleteMany?: TagScalarWhereInput[];
}

@InputType()
export class ProfileUpdateOneWithoutUserNestedInput {
  @Field(() => ProfileCreateWithoutUserInput, { nullable: true })
  create?: ProfileCreateWithoutUserInput;
  @Field(() => ProfileCreateOrConnectWithoutUserInput, { nullable: true })
  connectOrCreate?: ProfileCreateOrConnectWithoutUserInput;
  @Field(() => ProfileUpsertWithoutUserInput, { nullable: true })
  upsert?: ProfileUpsertWithoutUserInput;
  @Field(() => ProfileWhereInput, { nullable: true })
  disconnect?: ProfileWhereInput;
  @Field(() => ProfileWhereInput, { nullable: true })
  delete?: ProfileWhereInput;
  @Field(() => ProfileWhereUniqueInput, { nullable: true })
  connect?: ProfileWhereUniqueInput;
  @Field(() => ProfileUpdateToOneWithWhereWithoutUserInput, { nullable: true })
  update?: ProfileUpdateToOneWithWhereWithoutUserInput;
}

@InputType()
export class IntFieldUpdateOperationsInput {
  @Field(() => Int, { nullable: true })
  set?: number;
  @Field(() => Int, { nullable: true })
  increment?: number;
  @Field(() => Int, { nullable: true })
  decrement?: number;
  @Field(() => Int, { nullable: true })
  multiply?: number;
  @Field(() => Int, { nullable: true })
  divide?: number;
}

@InputType()
export class NullableIntFieldUpdateOperationsInput {
  @Field(() => Int, { nullable: true })
  set?: number;
  @Field(() => Int, { nullable: true })
  increment?: number;
  @Field(() => Int, { nullable: true })
  decrement?: number;
  @Field(() => Int, { nullable: true })
  multiply?: number;
  @Field(() => Int, { nullable: true })
  divide?: number;
}

@InputType()
export class PostUncheckedUpdateManyWithoutAuthorNestedInput {
  @Field(() => [PostCreateWithoutAuthorInput], { nullable: true })
  create?: PostCreateWithoutAuthorInput[];
  @Field(() => [PostCreateOrConnectWithoutAuthorInput], { nullable: true })
  connectOrCreate?: PostCreateOrConnectWithoutAuthorInput[];
  @Field(() => [PostUpsertWithWhereUniqueWithoutAuthorInput], {
    nullable: true,
  })
  upsert?: PostUpsertWithWhereUniqueWithoutAuthorInput[];
  @Field(() => PostCreateManyAuthorInputEnvelope, { nullable: true })
  createMany?: PostCreateManyAuthorInputEnvelope;
  @Field(() => [PostWhereUniqueInput], { nullable: true })
  set?: PostWhereUniqueInput[];
  @Field(() => [PostWhereUniqueInput], { nullable: true })
  disconnect?: PostWhereUniqueInput[];
  @Field(() => [PostWhereUniqueInput], { nullable: true })
  delete?: PostWhereUniqueInput[];
  @Field(() => [PostWhereUniqueInput], { nullable: true })
  connect?: PostWhereUniqueInput[];
  @Field(() => [PostUpdateWithWhereUniqueWithoutAuthorInput], {
    nullable: true,
  })
  update?: PostUpdateWithWhereUniqueWithoutAuthorInput[];
  @Field(() => [PostUpdateManyWithWhereWithoutAuthorInput], { nullable: true })
  updateMany?: PostUpdateManyWithWhereWithoutAuthorInput[];
  @Field(() => [PostScalarWhereInput], { nullable: true })
  deleteMany?: PostScalarWhereInput[];
}

@InputType()
export class UserUncheckedUpdateManyWithoutParentNestedInput {
  @Field(() => [UserCreateWithoutParentInput], { nullable: true })
  create?: UserCreateWithoutParentInput[];
  @Field(() => [UserCreateOrConnectWithoutParentInput], { nullable: true })
  connectOrCreate?: UserCreateOrConnectWithoutParentInput[];
  @Field(() => [UserUpsertWithWhereUniqueWithoutParentInput], {
    nullable: true,
  })
  upsert?: UserUpsertWithWhereUniqueWithoutParentInput[];
  @Field(() => UserCreateManyParentInputEnvelope, { nullable: true })
  createMany?: UserCreateManyParentInputEnvelope;
  @Field(() => [UserWhereUniqueInput], { nullable: true })
  set?: UserWhereUniqueInput[];
  @Field(() => [UserWhereUniqueInput], { nullable: true })
  disconnect?: UserWhereUniqueInput[];
  @Field(() => [UserWhereUniqueInput], { nullable: true })
  delete?: UserWhereUniqueInput[];
  @Field(() => [UserWhereUniqueInput], { nullable: true })
  connect?: UserWhereUniqueInput[];
  @Field(() => [UserUpdateWithWhereUniqueWithoutParentInput], {
    nullable: true,
  })
  update?: UserUpdateWithWhereUniqueWithoutParentInput[];
  @Field(() => [UserUpdateManyWithWhereWithoutParentInput], { nullable: true })
  updateMany?: UserUpdateManyWithWhereWithoutParentInput[];
  @Field(() => [UserScalarWhereInput], { nullable: true })
  deleteMany?: UserScalarWhereInput[];
}

@InputType()
export class PostUncheckedUpdateManyWithoutAnotherAuthorNestedInput {
  @Field(() => [PostCreateWithoutAnotherAuthorInput], { nullable: true })
  create?: PostCreateWithoutAnotherAuthorInput[];
  @Field(() => [PostCreateOrConnectWithoutAnotherAuthorInput], {
    nullable: true,
  })
  connectOrCreate?: PostCreateOrConnectWithoutAnotherAuthorInput[];
  @Field(() => [PostUpsertWithWhereUniqueWithoutAnotherAuthorInput], {
    nullable: true,
  })
  upsert?: PostUpsertWithWhereUniqueWithoutAnotherAuthorInput[];
  @Field(() => PostCreateManyAnotherAuthorInputEnvelope, { nullable: true })
  createMany?: PostCreateManyAnotherAuthorInputEnvelope;
  @Field(() => [PostWhereUniqueInput], { nullable: true })
  set?: PostWhereUniqueInput[];
  @Field(() => [PostWhereUniqueInput], { nullable: true })
  disconnect?: PostWhereUniqueInput[];
  @Field(() => [PostWhereUniqueInput], { nullable: true })
  delete?: PostWhereUniqueInput[];
  @Field(() => [PostWhereUniqueInput], { nullable: true })
  connect?: PostWhereUniqueInput[];
  @Field(() => [PostUpdateWithWhereUniqueWithoutAnotherAuthorInput], {
    nullable: true,
  })
  update?: PostUpdateWithWhereUniqueWithoutAnotherAuthorInput[];
  @Field(() => [PostUpdateManyWithWhereWithoutAnotherAuthorInput], {
    nullable: true,
  })
  updateMany?: PostUpdateManyWithWhereWithoutAnotherAuthorInput[];
  @Field(() => [PostScalarWhereInput], { nullable: true })
  deleteMany?: PostScalarWhereInput[];
}

@InputType()
export class TagUncheckedUpdateManyWithoutUsersNestedInput {
  @Field(() => [TagCreateWithoutUsersInput], { nullable: true })
  create?: TagCreateWithoutUsersInput[];
  @Field(() => [TagCreateOrConnectWithoutUsersInput], { nullable: true })
  connectOrCreate?: TagCreateOrConnectWithoutUsersInput[];
  @Field(() => [TagUpsertWithWhereUniqueWithoutUsersInput], { nullable: true })
  upsert?: TagUpsertWithWhereUniqueWithoutUsersInput[];
  @Field(() => [TagWhereUniqueInput], { nullable: true })
  set?: TagWhereUniqueInput[];
  @Field(() => [TagWhereUniqueInput], { nullable: true })
  disconnect?: TagWhereUniqueInput[];
  @Field(() => [TagWhereUniqueInput], { nullable: true })
  delete?: TagWhereUniqueInput[];
  @Field(() => [TagWhereUniqueInput], { nullable: true })
  connect?: TagWhereUniqueInput[];
  @Field(() => [TagUpdateWithWhereUniqueWithoutUsersInput], { nullable: true })
  update?: TagUpdateWithWhereUniqueWithoutUsersInput[];
  @Field(() => [TagUpdateManyWithWhereWithoutUsersInput], { nullable: true })
  updateMany?: TagUpdateManyWithWhereWithoutUsersInput[];
  @Field(() => [TagScalarWhereInput], { nullable: true })
  deleteMany?: TagScalarWhereInput[];
}

@InputType()
export class ProfileUncheckedUpdateOneWithoutUserNestedInput {
  @Field(() => ProfileCreateWithoutUserInput, { nullable: true })
  create?: ProfileCreateWithoutUserInput;
  @Field(() => ProfileCreateOrConnectWithoutUserInput, { nullable: true })
  connectOrCreate?: ProfileCreateOrConnectWithoutUserInput;
  @Field(() => ProfileUpsertWithoutUserInput, { nullable: true })
  upsert?: ProfileUpsertWithoutUserInput;
  @Field(() => ProfileWhereInput, { nullable: true })
  disconnect?: ProfileWhereInput;
  @Field(() => ProfileWhereInput, { nullable: true })
  delete?: ProfileWhereInput;
  @Field(() => ProfileWhereUniqueInput, { nullable: true })
  connect?: ProfileWhereUniqueInput;
  @Field(() => ProfileUpdateToOneWithWhereWithoutUserInput, { nullable: true })
  update?: ProfileUpdateToOneWithWhereWithoutUserInput;
}

@InputType()
export class UserCreateNestedOneWithoutProfileInput {
  @Field(() => UserCreateWithoutProfileInput, { nullable: true })
  create?: UserCreateWithoutProfileInput;
  @Field(() => UserCreateOrConnectWithoutProfileInput, { nullable: true })
  connectOrCreate?: UserCreateOrConnectWithoutProfileInput;
  @Field(() => UserWhereUniqueInput, { nullable: true })
  connect?: UserWhereUniqueInput;
}

@InputType()
export class UserUpdateOneRequiredWithoutProfileNestedInput {
  @Field(() => UserCreateWithoutProfileInput, { nullable: true })
  create?: UserCreateWithoutProfileInput;
  @Field(() => UserCreateOrConnectWithoutProfileInput, { nullable: true })
  connectOrCreate?: UserCreateOrConnectWithoutProfileInput;
  @Field(() => UserUpsertWithoutProfileInput, { nullable: true })
  upsert?: UserUpsertWithoutProfileInput;
  @Field(() => UserWhereUniqueInput, { nullable: true })
  connect?: UserWhereUniqueInput;
  @Field(() => UserUpdateToOneWithWhereWithoutProfileInput, { nullable: true })
  update?: UserUpdateToOneWithWhereWithoutProfileInput;
}

@InputType()
export class UserCreateNestedOneWithoutPostsInput {
  @Field(() => UserCreateWithoutPostsInput, { nullable: true })
  create?: UserCreateWithoutPostsInput;
  @Field(() => UserCreateOrConnectWithoutPostsInput, { nullable: true })
  connectOrCreate?: UserCreateOrConnectWithoutPostsInput;
  @Field(() => UserWhereUniqueInput, { nullable: true })
  connect?: UserWhereUniqueInput;
}

@InputType()
export class UserCreateNestedOneWithoutAnotherPostsInput {
  @Field(() => UserCreateWithoutAnotherPostsInput, { nullable: true })
  create?: UserCreateWithoutAnotherPostsInput;
  @Field(() => UserCreateOrConnectWithoutAnotherPostsInput, { nullable: true })
  connectOrCreate?: UserCreateOrConnectWithoutAnotherPostsInput;
  @Field(() => UserWhereUniqueInput, { nullable: true })
  connect?: UserWhereUniqueInput;
}

@InputType()
export class CategoryCreateNestedManyWithoutPostsInput {
  @Field(() => [CategoryCreateWithoutPostsInput], { nullable: true })
  create?: CategoryCreateWithoutPostsInput[];
  @Field(() => [CategoryCreateOrConnectWithoutPostsInput], { nullable: true })
  connectOrCreate?: CategoryCreateOrConnectWithoutPostsInput[];
  @Field(() => [CategoryWhereUniqueInput], { nullable: true })
  connect?: CategoryWhereUniqueInput[];
}

@InputType()
export class CategoryUncheckedCreateNestedManyWithoutPostsInput {
  @Field(() => [CategoryCreateWithoutPostsInput], { nullable: true })
  create?: CategoryCreateWithoutPostsInput[];
  @Field(() => [CategoryCreateOrConnectWithoutPostsInput], { nullable: true })
  connectOrCreate?: CategoryCreateOrConnectWithoutPostsInput[];
  @Field(() => [CategoryWhereUniqueInput], { nullable: true })
  connect?: CategoryWhereUniqueInput[];
}

@InputType()
export class BoolFieldUpdateOperationsInput {
  @Field(() => Boolean, { nullable: true })
  set?: boolean;
}

@InputType()
export class UserUpdateOneRequiredWithoutPostsNestedInput {
  @Field(() => UserCreateWithoutPostsInput, { nullable: true })
  create?: UserCreateWithoutPostsInput;
  @Field(() => UserCreateOrConnectWithoutPostsInput, { nullable: true })
  connectOrCreate?: UserCreateOrConnectWithoutPostsInput;
  @Field(() => UserUpsertWithoutPostsInput, { nullable: true })
  upsert?: UserUpsertWithoutPostsInput;
  @Field(() => UserWhereUniqueInput, { nullable: true })
  connect?: UserWhereUniqueInput;
  @Field(() => UserUpdateToOneWithWhereWithoutPostsInput, { nullable: true })
  update?: UserUpdateToOneWithWhereWithoutPostsInput;
}

@InputType()
export class UserUpdateOneRequiredWithoutAnotherPostsNestedInput {
  @Field(() => UserCreateWithoutAnotherPostsInput, { nullable: true })
  create?: UserCreateWithoutAnotherPostsInput;
  @Field(() => UserCreateOrConnectWithoutAnotherPostsInput, { nullable: true })
  connectOrCreate?: UserCreateOrConnectWithoutAnotherPostsInput;
  @Field(() => UserUpsertWithoutAnotherPostsInput, { nullable: true })
  upsert?: UserUpsertWithoutAnotherPostsInput;
  @Field(() => UserWhereUniqueInput, { nullable: true })
  connect?: UserWhereUniqueInput;
  @Field(() => UserUpdateToOneWithWhereWithoutAnotherPostsInput, {
    nullable: true,
  })
  update?: UserUpdateToOneWithWhereWithoutAnotherPostsInput;
}

@InputType()
export class CategoryUpdateManyWithoutPostsNestedInput {
  @Field(() => [CategoryCreateWithoutPostsInput], { nullable: true })
  create?: CategoryCreateWithoutPostsInput[];
  @Field(() => [CategoryCreateOrConnectWithoutPostsInput], { nullable: true })
  connectOrCreate?: CategoryCreateOrConnectWithoutPostsInput[];
  @Field(() => [CategoryUpsertWithWhereUniqueWithoutPostsInput], {
    nullable: true,
  })
  upsert?: CategoryUpsertWithWhereUniqueWithoutPostsInput[];
  @Field(() => [CategoryWhereUniqueInput], { nullable: true })
  set?: CategoryWhereUniqueInput[];
  @Field(() => [CategoryWhereUniqueInput], { nullable: true })
  disconnect?: CategoryWhereUniqueInput[];
  @Field(() => [CategoryWhereUniqueInput], { nullable: true })
  delete?: CategoryWhereUniqueInput[];
  @Field(() => [CategoryWhereUniqueInput], { nullable: true })
  connect?: CategoryWhereUniqueInput[];
  @Field(() => [CategoryUpdateWithWhereUniqueWithoutPostsInput], {
    nullable: true,
  })
  update?: CategoryUpdateWithWhereUniqueWithoutPostsInput[];
  @Field(() => [CategoryUpdateManyWithWhereWithoutPostsInput], {
    nullable: true,
  })
  updateMany?: CategoryUpdateManyWithWhereWithoutPostsInput[];
  @Field(() => [CategoryScalarWhereInput], { nullable: true })
  deleteMany?: CategoryScalarWhereInput[];
}

@InputType()
export class CategoryUncheckedUpdateManyWithoutPostsNestedInput {
  @Field(() => [CategoryCreateWithoutPostsInput], { nullable: true })
  create?: CategoryCreateWithoutPostsInput[];
  @Field(() => [CategoryCreateOrConnectWithoutPostsInput], { nullable: true })
  connectOrCreate?: CategoryCreateOrConnectWithoutPostsInput[];
  @Field(() => [CategoryUpsertWithWhereUniqueWithoutPostsInput], {
    nullable: true,
  })
  upsert?: CategoryUpsertWithWhereUniqueWithoutPostsInput[];
  @Field(() => [CategoryWhereUniqueInput], { nullable: true })
  set?: CategoryWhereUniqueInput[];
  @Field(() => [CategoryWhereUniqueInput], { nullable: true })
  disconnect?: CategoryWhereUniqueInput[];
  @Field(() => [CategoryWhereUniqueInput], { nullable: true })
  delete?: CategoryWhereUniqueInput[];
  @Field(() => [CategoryWhereUniqueInput], { nullable: true })
  connect?: CategoryWhereUniqueInput[];
  @Field(() => [CategoryUpdateWithWhereUniqueWithoutPostsInput], {
    nullable: true,
  })
  update?: CategoryUpdateWithWhereUniqueWithoutPostsInput[];
  @Field(() => [CategoryUpdateManyWithWhereWithoutPostsInput], {
    nullable: true,
  })
  updateMany?: CategoryUpdateManyWithWhereWithoutPostsInput[];
  @Field(() => [CategoryScalarWhereInput], { nullable: true })
  deleteMany?: CategoryScalarWhereInput[];
}

@InputType()
export class UserCreateNestedManyWithoutTagsInput {
  @Field(() => [UserCreateWithoutTagsInput], { nullable: true })
  create?: UserCreateWithoutTagsInput[];
  @Field(() => [UserCreateOrConnectWithoutTagsInput], { nullable: true })
  connectOrCreate?: UserCreateOrConnectWithoutTagsInput[];
  @Field(() => [UserWhereUniqueInput], { nullable: true })
  connect?: UserWhereUniqueInput[];
}

@InputType()
export class UserUncheckedCreateNestedManyWithoutTagsInput {
  @Field(() => [UserCreateWithoutTagsInput], { nullable: true })
  create?: UserCreateWithoutTagsInput[];
  @Field(() => [UserCreateOrConnectWithoutTagsInput], { nullable: true })
  connectOrCreate?: UserCreateOrConnectWithoutTagsInput[];
  @Field(() => [UserWhereUniqueInput], { nullable: true })
  connect?: UserWhereUniqueInput[];
}

@InputType()
export class UserUpdateManyWithoutTagsNestedInput {
  @Field(() => [UserCreateWithoutTagsInput], { nullable: true })
  create?: UserCreateWithoutTagsInput[];
  @Field(() => [UserCreateOrConnectWithoutTagsInput], { nullable: true })
  connectOrCreate?: UserCreateOrConnectWithoutTagsInput[];
  @Field(() => [UserUpsertWithWhereUniqueWithoutTagsInput], { nullable: true })
  upsert?: UserUpsertWithWhereUniqueWithoutTagsInput[];
  @Field(() => [UserWhereUniqueInput], { nullable: true })
  set?: UserWhereUniqueInput[];
  @Field(() => [UserWhereUniqueInput], { nullable: true })
  disconnect?: UserWhereUniqueInput[];
  @Field(() => [UserWhereUniqueInput], { nullable: true })
  delete?: UserWhereUniqueInput[];
  @Field(() => [UserWhereUniqueInput], { nullable: true })
  connect?: UserWhereUniqueInput[];
  @Field(() => [UserUpdateWithWhereUniqueWithoutTagsInput], { nullable: true })
  update?: UserUpdateWithWhereUniqueWithoutTagsInput[];
  @Field(() => [UserUpdateManyWithWhereWithoutTagsInput], { nullable: true })
  updateMany?: UserUpdateManyWithWhereWithoutTagsInput[];
  @Field(() => [UserScalarWhereInput], { nullable: true })
  deleteMany?: UserScalarWhereInput[];
}

@InputType()
export class UserUncheckedUpdateManyWithoutTagsNestedInput {
  @Field(() => [UserCreateWithoutTagsInput], { nullable: true })
  create?: UserCreateWithoutTagsInput[];
  @Field(() => [UserCreateOrConnectWithoutTagsInput], { nullable: true })
  connectOrCreate?: UserCreateOrConnectWithoutTagsInput[];
  @Field(() => [UserUpsertWithWhereUniqueWithoutTagsInput], { nullable: true })
  upsert?: UserUpsertWithWhereUniqueWithoutTagsInput[];
  @Field(() => [UserWhereUniqueInput], { nullable: true })
  set?: UserWhereUniqueInput[];
  @Field(() => [UserWhereUniqueInput], { nullable: true })
  disconnect?: UserWhereUniqueInput[];
  @Field(() => [UserWhereUniqueInput], { nullable: true })
  delete?: UserWhereUniqueInput[];
  @Field(() => [UserWhereUniqueInput], { nullable: true })
  connect?: UserWhereUniqueInput[];
  @Field(() => [UserUpdateWithWhereUniqueWithoutTagsInput], { nullable: true })
  update?: UserUpdateWithWhereUniqueWithoutTagsInput[];
  @Field(() => [UserUpdateManyWithWhereWithoutTagsInput], { nullable: true })
  updateMany?: UserUpdateManyWithWhereWithoutTagsInput[];
  @Field(() => [UserScalarWhereInput], { nullable: true })
  deleteMany?: UserScalarWhereInput[];
}

@InputType()
export class PostCreateNestedManyWithoutCategoriesInput {
  @Field(() => [PostCreateWithoutCategoriesInput], { nullable: true })
  create?: PostCreateWithoutCategoriesInput[];
  @Field(() => [PostCreateOrConnectWithoutCategoriesInput], { nullable: true })
  connectOrCreate?: PostCreateOrConnectWithoutCategoriesInput[];
  @Field(() => [PostWhereUniqueInput], { nullable: true })
  connect?: PostWhereUniqueInput[];
}

@InputType()
export class CategoryMetadataCreateNestedOneWithoutCategoryInput {
  @Field(() => CategoryMetadataCreateWithoutCategoryInput, { nullable: true })
  create?: CategoryMetadataCreateWithoutCategoryInput;
  @Field(() => CategoryMetadataCreateOrConnectWithoutCategoryInput, {
    nullable: true,
  })
  connectOrCreate?: CategoryMetadataCreateOrConnectWithoutCategoryInput;
  @Field(() => CategoryMetadataWhereUniqueInput, { nullable: true })
  connect?: CategoryMetadataWhereUniqueInput;
}

@InputType()
export class PostUncheckedCreateNestedManyWithoutCategoriesInput {
  @Field(() => [PostCreateWithoutCategoriesInput], { nullable: true })
  create?: PostCreateWithoutCategoriesInput[];
  @Field(() => [PostCreateOrConnectWithoutCategoriesInput], { nullable: true })
  connectOrCreate?: PostCreateOrConnectWithoutCategoriesInput[];
  @Field(() => [PostWhereUniqueInput], { nullable: true })
  connect?: PostWhereUniqueInput[];
}

@InputType()
export class CategoryMetadataUncheckedCreateNestedOneWithoutCategoryInput {
  @Field(() => CategoryMetadataCreateWithoutCategoryInput, { nullable: true })
  create?: CategoryMetadataCreateWithoutCategoryInput;
  @Field(() => CategoryMetadataCreateOrConnectWithoutCategoryInput, {
    nullable: true,
  })
  connectOrCreate?: CategoryMetadataCreateOrConnectWithoutCategoryInput;
  @Field(() => CategoryMetadataWhereUniqueInput, { nullable: true })
  connect?: CategoryMetadataWhereUniqueInput;
}

@InputType()
export class PostUpdateManyWithoutCategoriesNestedInput {
  @Field(() => [PostCreateWithoutCategoriesInput], { nullable: true })
  create?: PostCreateWithoutCategoriesInput[];
  @Field(() => [PostCreateOrConnectWithoutCategoriesInput], { nullable: true })
  connectOrCreate?: PostCreateOrConnectWithoutCategoriesInput[];
  @Field(() => [PostUpsertWithWhereUniqueWithoutCategoriesInput], {
    nullable: true,
  })
  upsert?: PostUpsertWithWhereUniqueWithoutCategoriesInput[];
  @Field(() => [PostWhereUniqueInput], { nullable: true })
  set?: PostWhereUniqueInput[];
  @Field(() => [PostWhereUniqueInput], { nullable: true })
  disconnect?: PostWhereUniqueInput[];
  @Field(() => [PostWhereUniqueInput], { nullable: true })
  delete?: PostWhereUniqueInput[];
  @Field(() => [PostWhereUniqueInput], { nullable: true })
  connect?: PostWhereUniqueInput[];
  @Field(() => [PostUpdateWithWhereUniqueWithoutCategoriesInput], {
    nullable: true,
  })
  update?: PostUpdateWithWhereUniqueWithoutCategoriesInput[];
  @Field(() => [PostUpdateManyWithWhereWithoutCategoriesInput], {
    nullable: true,
  })
  updateMany?: PostUpdateManyWithWhereWithoutCategoriesInput[];
  @Field(() => [PostScalarWhereInput], { nullable: true })
  deleteMany?: PostScalarWhereInput[];
}

@InputType()
export class CategoryMetadataUpdateOneWithoutCategoryNestedInput {
  @Field(() => CategoryMetadataCreateWithoutCategoryInput, { nullable: true })
  create?: CategoryMetadataCreateWithoutCategoryInput;
  @Field(() => CategoryMetadataCreateOrConnectWithoutCategoryInput, {
    nullable: true,
  })
  connectOrCreate?: CategoryMetadataCreateOrConnectWithoutCategoryInput;
  @Field(() => CategoryMetadataUpsertWithoutCategoryInput, { nullable: true })
  upsert?: CategoryMetadataUpsertWithoutCategoryInput;
  @Field(() => CategoryMetadataWhereInput, { nullable: true })
  disconnect?: CategoryMetadataWhereInput;
  @Field(() => CategoryMetadataWhereInput, { nullable: true })
  delete?: CategoryMetadataWhereInput;
  @Field(() => CategoryMetadataWhereUniqueInput, { nullable: true })
  connect?: CategoryMetadataWhereUniqueInput;
  @Field(() => CategoryMetadataUpdateToOneWithWhereWithoutCategoryInput, {
    nullable: true,
  })
  update?: CategoryMetadataUpdateToOneWithWhereWithoutCategoryInput;
}

@InputType()
export class PostUncheckedUpdateManyWithoutCategoriesNestedInput {
  @Field(() => [PostCreateWithoutCategoriesInput], { nullable: true })
  create?: PostCreateWithoutCategoriesInput[];
  @Field(() => [PostCreateOrConnectWithoutCategoriesInput], { nullable: true })
  connectOrCreate?: PostCreateOrConnectWithoutCategoriesInput[];
  @Field(() => [PostUpsertWithWhereUniqueWithoutCategoriesInput], {
    nullable: true,
  })
  upsert?: PostUpsertWithWhereUniqueWithoutCategoriesInput[];
  @Field(() => [PostWhereUniqueInput], { nullable: true })
  set?: PostWhereUniqueInput[];
  @Field(() => [PostWhereUniqueInput], { nullable: true })
  disconnect?: PostWhereUniqueInput[];
  @Field(() => [PostWhereUniqueInput], { nullable: true })
  delete?: PostWhereUniqueInput[];
  @Field(() => [PostWhereUniqueInput], { nullable: true })
  connect?: PostWhereUniqueInput[];
  @Field(() => [PostUpdateWithWhereUniqueWithoutCategoriesInput], {
    nullable: true,
  })
  update?: PostUpdateWithWhereUniqueWithoutCategoriesInput[];
  @Field(() => [PostUpdateManyWithWhereWithoutCategoriesInput], {
    nullable: true,
  })
  updateMany?: PostUpdateManyWithWhereWithoutCategoriesInput[];
  @Field(() => [PostScalarWhereInput], { nullable: true })
  deleteMany?: PostScalarWhereInput[];
}

@InputType()
export class CategoryMetadataUncheckedUpdateOneWithoutCategoryNestedInput {
  @Field(() => CategoryMetadataCreateWithoutCategoryInput, { nullable: true })
  create?: CategoryMetadataCreateWithoutCategoryInput;
  @Field(() => CategoryMetadataCreateOrConnectWithoutCategoryInput, {
    nullable: true,
  })
  connectOrCreate?: CategoryMetadataCreateOrConnectWithoutCategoryInput;
  @Field(() => CategoryMetadataUpsertWithoutCategoryInput, { nullable: true })
  upsert?: CategoryMetadataUpsertWithoutCategoryInput;
  @Field(() => CategoryMetadataWhereInput, { nullable: true })
  disconnect?: CategoryMetadataWhereInput;
  @Field(() => CategoryMetadataWhereInput, { nullable: true })
  delete?: CategoryMetadataWhereInput;
  @Field(() => CategoryMetadataWhereUniqueInput, { nullable: true })
  connect?: CategoryMetadataWhereUniqueInput;
  @Field(() => CategoryMetadataUpdateToOneWithWhereWithoutCategoryInput, {
    nullable: true,
  })
  update?: CategoryMetadataUpdateToOneWithWhereWithoutCategoryInput;
}

@InputType()
export class CategoryMetadataCreatemetadataInput {
  @Field(() => [GraphQLJSON], { nullable: false })
  set: any[];
}

@InputType()
export class CategoryCreateNestedOneWithoutMetadataInput {
  @Field(() => CategoryCreateWithoutMetadataInput, { nullable: true })
  create?: CategoryCreateWithoutMetadataInput;
  @Field(() => CategoryCreateOrConnectWithoutMetadataInput, { nullable: true })
  connectOrCreate?: CategoryCreateOrConnectWithoutMetadataInput;
  @Field(() => CategoryWhereUniqueInput, { nullable: true })
  connect?: CategoryWhereUniqueInput;
}

@InputType()
export class CategoryMetadataUpdatemetadataInput {
  @Field(() => [GraphQLJSON], { nullable: true })
  set?: any[];
  @Field(() => [GraphQLJSON], { nullable: true })
  push?: any[];
}

@InputType()
export class CategoryUpdateOneRequiredWithoutMetadataNestedInput {
  @Field(() => CategoryCreateWithoutMetadataInput, { nullable: true })
  create?: CategoryCreateWithoutMetadataInput;
  @Field(() => CategoryCreateOrConnectWithoutMetadataInput, { nullable: true })
  connectOrCreate?: CategoryCreateOrConnectWithoutMetadataInput;
  @Field(() => CategoryUpsertWithoutMetadataInput, { nullable: true })
  upsert?: CategoryUpsertWithoutMetadataInput;
  @Field(() => CategoryWhereUniqueInput, { nullable: true })
  connect?: CategoryWhereUniqueInput;
  @Field(() => CategoryUpdateToOneWithWhereWithoutMetadataInput, {
    nullable: true,
  })
  update?: CategoryUpdateToOneWithWhereWithoutMetadataInput;
}

@InputType()
export class MiscModelCreatejsonListInput {
  @Field(() => [GraphQLJSON], { nullable: false })
  set: any[];
}

@InputType()
export class MiscModelCreatestringListInput {
  @Field(() => [String], { nullable: false })
  set: string[];
}

@InputType()
export class MiscModelCreatedecimalListInput {
  @Field(() => [GraphQLHexadecimal], { nullable: false })
  set: string[];
}

@InputType()
export class MiscModelCreatebytesListInput {
  @Field(() => [GraphQLByte], { nullable: false })
  set: Buffer[];
}

@InputType()
export class MiscModelCreatebigIntListInput {
  @Field(() => [GraphQLBigInt], { nullable: false })
  set: bigint[];
}

@InputType()
export class MiscModelCreatedateTimeListInput {
  @Field(() => [Date], { nullable: false })
  set: Date[];
}

@InputType()
export class MiscModelUpdatejsonListInput {
  @Field(() => [GraphQLJSON], { nullable: true })
  set?: any[];
  @Field(() => [GraphQLJSON], { nullable: true })
  push?: any[];
}

@InputType()
export class MiscModelUpdatestringListInput {
  @Field(() => [String], { nullable: true })
  set?: string[];
  @Field(() => [String], { nullable: true })
  push?: string[];
}

@InputType()
export class DecimalFieldUpdateOperationsInput {
  @Field(() => GraphQLHexadecimal, { nullable: true })
  set?: string;
  @Field(() => GraphQLHexadecimal, { nullable: true })
  increment?: string;
  @Field(() => GraphQLHexadecimal, { nullable: true })
  decrement?: string;
  @Field(() => GraphQLHexadecimal, { nullable: true })
  multiply?: string;
  @Field(() => GraphQLHexadecimal, { nullable: true })
  divide?: string;
}

@InputType()
export class MiscModelUpdatedecimalListInput {
  @Field(() => [GraphQLHexadecimal], { nullable: true })
  set?: string[];
  @Field(() => [GraphQLHexadecimal], { nullable: true })
  push?: string[];
}

@InputType()
export class FloatFieldUpdateOperationsInput {
  @Field(() => Float, { nullable: true })
  set?: number;
  @Field(() => Float, { nullable: true })
  increment?: number;
  @Field(() => Float, { nullable: true })
  decrement?: number;
  @Field(() => Float, { nullable: true })
  multiply?: number;
  @Field(() => Float, { nullable: true })
  divide?: number;
}

@InputType()
export class BytesFieldUpdateOperationsInput {
  @Field(() => GraphQLByte, { nullable: true })
  set?: Buffer;
}

@InputType()
export class MiscModelUpdatebytesListInput {
  @Field(() => [GraphQLByte], { nullable: true })
  set?: Buffer[];
  @Field(() => [GraphQLByte], { nullable: true })
  push?: Buffer[];
}

@InputType()
export class BigIntFieldUpdateOperationsInput {
  @Field(() => GraphQLBigInt, { nullable: true })
  set?: bigint;
  @Field(() => GraphQLBigInt, { nullable: true })
  increment?: bigint;
  @Field(() => GraphQLBigInt, { nullable: true })
  decrement?: bigint;
  @Field(() => GraphQLBigInt, { nullable: true })
  multiply?: bigint;
  @Field(() => GraphQLBigInt, { nullable: true })
  divide?: bigint;
}

@InputType()
export class MiscModelUpdatebigIntListInput {
  @Field(() => [GraphQLBigInt], { nullable: true })
  set?: bigint[];
  @Field(() => [GraphQLBigInt], { nullable: true })
  push?: bigint[];
}

@InputType()
export class MiscModelUpdatedateTimeListInput {
  @Field(() => [Date], { nullable: true })
  set?: Date[];
  @Field(() => [Date], { nullable: true })
  push?: Date[];
}

@InputType()
export class NestedIntFilter {
  @Field(() => Int, { nullable: true })
  equals?: number;
  @Field(() => [Int], { nullable: true })
  in?: number[];
  @Field(() => [Int], { nullable: true })
  notIn?: number[];
  @Field(() => Int, { nullable: true })
  lt?: number;
  @Field(() => Int, { nullable: true })
  lte?: number;
  @Field(() => Int, { nullable: true })
  gt?: number;
  @Field(() => Int, { nullable: true })
  gte?: number;
  @Field(() => NestedIntFilter, { nullable: true })
  not?: NestedIntFilter;
}

@InputType()
export class NestedDateTimeFilter {
  @Field(() => Date, { nullable: true })
  equals?: Date;
  @Field(() => [Date], { nullable: true })
  in?: Date[];
  @Field(() => [Date], { nullable: true })
  notIn?: Date[];
  @Field(() => Date, { nullable: true })
  lt?: Date;
  @Field(() => Date, { nullable: true })
  lte?: Date;
  @Field(() => Date, { nullable: true })
  gt?: Date;
  @Field(() => Date, { nullable: true })
  gte?: Date;
  @Field(() => NestedDateTimeFilter, { nullable: true })
  not?: NestedDateTimeFilter;
}

@InputType()
export class NestedStringFilter {
  @Field(() => String, { nullable: true })
  equals?: string;
  @Field(() => [String], { nullable: true })
  in?: string[];
  @Field(() => [String], { nullable: true })
  notIn?: string[];
  @Field(() => String, { nullable: true })
  lt?: string;
  @Field(() => String, { nullable: true })
  lte?: string;
  @Field(() => String, { nullable: true })
  gt?: string;
  @Field(() => String, { nullable: true })
  gte?: string;
  @Field(() => String, { nullable: true })
  contains?: string;
  @Field(() => String, { nullable: true })
  startsWith?: string;
  @Field(() => String, { nullable: true })
  endsWith?: string;
  @Field(() => NestedStringFilter, { nullable: true })
  not?: NestedStringFilter;
}

@InputType()
export class NestedStringNullableFilter {
  @Field(() => String, { nullable: true })
  equals?: string;
  @Field(() => [String], { nullable: true })
  in?: string[];
  @Field(() => [String], { nullable: true })
  notIn?: string[];
  @Field(() => String, { nullable: true })
  lt?: string;
  @Field(() => String, { nullable: true })
  lte?: string;
  @Field(() => String, { nullable: true })
  gt?: string;
  @Field(() => String, { nullable: true })
  gte?: string;
  @Field(() => String, { nullable: true })
  contains?: string;
  @Field(() => String, { nullable: true })
  startsWith?: string;
  @Field(() => String, { nullable: true })
  endsWith?: string;
  @Field(() => NestedStringNullableFilter, { nullable: true })
  not?: NestedStringNullableFilter;
}

@InputType()
export class NestedEnumUserRoleFilter {
  @Field(() => UserRole, { nullable: true })
  equals?: UserRole;
  @Field(() => [UserRole], { nullable: true })
  in?: UserRole[];
  @Field(() => [UserRole], { nullable: true })
  notIn?: UserRole[];
  @Field(() => UserRole, { nullable: true })
  not?: UserRole;
}

@InputType()
export class NestedIntNullableFilter {
  @Field(() => Int, { nullable: true })
  equals?: number;
  @Field(() => [Int], { nullable: true })
  in?: number[];
  @Field(() => [Int], { nullable: true })
  notIn?: number[];
  @Field(() => Int, { nullable: true })
  lt?: number;
  @Field(() => Int, { nullable: true })
  lte?: number;
  @Field(() => Int, { nullable: true })
  gt?: number;
  @Field(() => Int, { nullable: true })
  gte?: number;
  @Field(() => NestedIntNullableFilter, { nullable: true })
  not?: NestedIntNullableFilter;
}

@InputType()
export class NestedIntWithAggregatesFilter {
  @Field(() => Int, { nullable: true })
  equals?: number;
  @Field(() => [Int], { nullable: true })
  in?: number[];
  @Field(() => [Int], { nullable: true })
  notIn?: number[];
  @Field(() => Int, { nullable: true })
  lt?: number;
  @Field(() => Int, { nullable: true })
  lte?: number;
  @Field(() => Int, { nullable: true })
  gt?: number;
  @Field(() => Int, { nullable: true })
  gte?: number;
  @Field(() => NestedIntWithAggregatesFilter, { nullable: true })
  not?: NestedIntWithAggregatesFilter;
  @Field(() => NestedIntFilter, { nullable: true })
  _count?: NestedIntFilter;
  @Field(() => NestedFloatFilter, { nullable: true })
  _avg?: NestedFloatFilter;
  @Field(() => NestedIntFilter, { nullable: true })
  _sum?: NestedIntFilter;
  @Field(() => NestedIntFilter, { nullable: true })
  _min?: NestedIntFilter;
  @Field(() => NestedIntFilter, { nullable: true })
  _max?: NestedIntFilter;
}

@InputType()
export class NestedFloatFilter {
  @Field(() => Float, { nullable: true })
  equals?: number;
  @Field(() => [Float], { nullable: true })
  in?: number[];
  @Field(() => [Float], { nullable: true })
  notIn?: number[];
  @Field(() => Float, { nullable: true })
  lt?: number;
  @Field(() => Float, { nullable: true })
  lte?: number;
  @Field(() => Float, { nullable: true })
  gt?: number;
  @Field(() => Float, { nullable: true })
  gte?: number;
  @Field(() => NestedFloatFilter, { nullable: true })
  not?: NestedFloatFilter;
}

@InputType()
export class NestedDateTimeWithAggregatesFilter {
  @Field(() => Date, { nullable: true })
  equals?: Date;
  @Field(() => [Date], { nullable: true })
  in?: Date[];
  @Field(() => [Date], { nullable: true })
  notIn?: Date[];
  @Field(() => Date, { nullable: true })
  lt?: Date;
  @Field(() => Date, { nullable: true })
  lte?: Date;
  @Field(() => Date, { nullable: true })
  gt?: Date;
  @Field(() => Date, { nullable: true })
  gte?: Date;
  @Field(() => NestedDateTimeWithAggregatesFilter, { nullable: true })
  not?: NestedDateTimeWithAggregatesFilter;
  @Field(() => NestedIntFilter, { nullable: true })
  _count?: NestedIntFilter;
  @Field(() => NestedDateTimeFilter, { nullable: true })
  _min?: NestedDateTimeFilter;
  @Field(() => NestedDateTimeFilter, { nullable: true })
  _max?: NestedDateTimeFilter;
}

@InputType()
export class NestedStringWithAggregatesFilter {
  @Field(() => String, { nullable: true })
  equals?: string;
  @Field(() => [String], { nullable: true })
  in?: string[];
  @Field(() => [String], { nullable: true })
  notIn?: string[];
  @Field(() => String, { nullable: true })
  lt?: string;
  @Field(() => String, { nullable: true })
  lte?: string;
  @Field(() => String, { nullable: true })
  gt?: string;
  @Field(() => String, { nullable: true })
  gte?: string;
  @Field(() => String, { nullable: true })
  contains?: string;
  @Field(() => String, { nullable: true })
  startsWith?: string;
  @Field(() => String, { nullable: true })
  endsWith?: string;
  @Field(() => NestedStringWithAggregatesFilter, { nullable: true })
  not?: NestedStringWithAggregatesFilter;
  @Field(() => NestedIntFilter, { nullable: true })
  _count?: NestedIntFilter;
  @Field(() => NestedStringFilter, { nullable: true })
  _min?: NestedStringFilter;
  @Field(() => NestedStringFilter, { nullable: true })
  _max?: NestedStringFilter;
}

@InputType()
export class NestedStringNullableWithAggregatesFilter {
  @Field(() => String, { nullable: true })
  equals?: string;
  @Field(() => [String], { nullable: true })
  in?: string[];
  @Field(() => [String], { nullable: true })
  notIn?: string[];
  @Field(() => String, { nullable: true })
  lt?: string;
  @Field(() => String, { nullable: true })
  lte?: string;
  @Field(() => String, { nullable: true })
  gt?: string;
  @Field(() => String, { nullable: true })
  gte?: string;
  @Field(() => String, { nullable: true })
  contains?: string;
  @Field(() => String, { nullable: true })
  startsWith?: string;
  @Field(() => String, { nullable: true })
  endsWith?: string;
  @Field(() => NestedStringNullableWithAggregatesFilter, { nullable: true })
  not?: NestedStringNullableWithAggregatesFilter;
  @Field(() => NestedIntNullableFilter, { nullable: true })
  _count?: NestedIntNullableFilter;
  @Field(() => NestedStringNullableFilter, { nullable: true })
  _min?: NestedStringNullableFilter;
  @Field(() => NestedStringNullableFilter, { nullable: true })
  _max?: NestedStringNullableFilter;
}

@InputType()
export class NestedIntNullableWithAggregatesFilter {
  @Field(() => Int, { nullable: true })
  equals?: number;
  @Field(() => [Int], { nullable: true })
  in?: number[];
  @Field(() => [Int], { nullable: true })
  notIn?: number[];
  @Field(() => Int, { nullable: true })
  lt?: number;
  @Field(() => Int, { nullable: true })
  lte?: number;
  @Field(() => Int, { nullable: true })
  gt?: number;
  @Field(() => Int, { nullable: true })
  gte?: number;
  @Field(() => NestedIntNullableWithAggregatesFilter, { nullable: true })
  not?: NestedIntNullableWithAggregatesFilter;
  @Field(() => NestedIntNullableFilter, { nullable: true })
  _count?: NestedIntNullableFilter;
  @Field(() => NestedFloatNullableFilter, { nullable: true })
  _avg?: NestedFloatNullableFilter;
  @Field(() => NestedIntNullableFilter, { nullable: true })
  _sum?: NestedIntNullableFilter;
  @Field(() => NestedIntNullableFilter, { nullable: true })
  _min?: NestedIntNullableFilter;
  @Field(() => NestedIntNullableFilter, { nullable: true })
  _max?: NestedIntNullableFilter;
}

@InputType()
export class NestedFloatNullableFilter {
  @Field(() => Float, { nullable: true })
  equals?: number;
  @Field(() => [Float], { nullable: true })
  in?: number[];
  @Field(() => [Float], { nullable: true })
  notIn?: number[];
  @Field(() => Float, { nullable: true })
  lt?: number;
  @Field(() => Float, { nullable: true })
  lte?: number;
  @Field(() => Float, { nullable: true })
  gt?: number;
  @Field(() => Float, { nullable: true })
  gte?: number;
  @Field(() => NestedFloatNullableFilter, { nullable: true })
  not?: NestedFloatNullableFilter;
}

@InputType()
export class NestedBoolFilter {
  @Field(() => Boolean, { nullable: true })
  equals?: boolean;
  @Field(() => NestedBoolFilter, { nullable: true })
  not?: NestedBoolFilter;
}

@InputType()
export class NestedEnumPostKindFilter {
  @Field(() => PostKind, { nullable: true })
  equals?: PostKind;
  @Field(() => [PostKind], { nullable: true })
  in?: PostKind[];
  @Field(() => [PostKind], { nullable: true })
  notIn?: PostKind[];
  @Field(() => PostKind, { nullable: true })
  not?: PostKind;
}

@InputType()
export class NestedBoolWithAggregatesFilter {
  @Field(() => Boolean, { nullable: true })
  equals?: boolean;
  @Field(() => NestedBoolWithAggregatesFilter, { nullable: true })
  not?: NestedBoolWithAggregatesFilter;
  @Field(() => NestedIntFilter, { nullable: true })
  _count?: NestedIntFilter;
  @Field(() => NestedBoolFilter, { nullable: true })
  _min?: NestedBoolFilter;
  @Field(() => NestedBoolFilter, { nullable: true })
  _max?: NestedBoolFilter;
}

@InputType()
export class NestedDecimalFilter {
  @Field(() => GraphQLHexadecimal, { nullable: true })
  equals?: string;
  @Field(() => [GraphQLHexadecimal], { nullable: true })
  in?: string[];
  @Field(() => [GraphQLHexadecimal], { nullable: true })
  notIn?: string[];
  @Field(() => GraphQLHexadecimal, { nullable: true })
  lt?: string;
  @Field(() => GraphQLHexadecimal, { nullable: true })
  lte?: string;
  @Field(() => GraphQLHexadecimal, { nullable: true })
  gt?: string;
  @Field(() => GraphQLHexadecimal, { nullable: true })
  gte?: string;
  @Field(() => NestedDecimalFilter, { nullable: true })
  not?: NestedDecimalFilter;
}

@InputType()
export class NestedBytesFilter {
  @Field(() => GraphQLByte, { nullable: true })
  equals?: Buffer;
  @Field(() => [GraphQLByte], { nullable: true })
  in?: Buffer[];
  @Field(() => [GraphQLByte], { nullable: true })
  notIn?: Buffer[];
  @Field(() => NestedBytesFilter, { nullable: true })
  not?: NestedBytesFilter;
}

@InputType()
export class NestedBigIntFilter {
  @Field(() => GraphQLBigInt, { nullable: true })
  equals?: bigint;
  @Field(() => [GraphQLBigInt], { nullable: true })
  in?: bigint[];
  @Field(() => [GraphQLBigInt], { nullable: true })
  notIn?: bigint[];
  @Field(() => GraphQLBigInt, { nullable: true })
  lt?: bigint;
  @Field(() => GraphQLBigInt, { nullable: true })
  lte?: bigint;
  @Field(() => GraphQLBigInt, { nullable: true })
  gt?: bigint;
  @Field(() => GraphQLBigInt, { nullable: true })
  gte?: bigint;
  @Field(() => NestedBigIntFilter, { nullable: true })
  not?: NestedBigIntFilter;
}

@InputType()
export class NestedJsonFilter {
  @Field(() => GraphQLJSON, { nullable: true })
  equals?: any;
  @Field(() => [String], { nullable: true })
  path?: string[];
  @Field(() => String, { nullable: true })
  string_contains?: string;
  @Field(() => String, { nullable: true })
  string_starts_with?: string;
  @Field(() => String, { nullable: true })
  string_ends_with?: string;
  @Field(() => GraphQLJSON, { nullable: true })
  array_contains?: any;
  @Field(() => GraphQLJSON, { nullable: true })
  array_starts_with?: any;
  @Field(() => GraphQLJSON, { nullable: true })
  array_ends_with?: any;
  @Field(() => GraphQLJSON, { nullable: true })
  lt?: any;
  @Field(() => GraphQLJSON, { nullable: true })
  lte?: any;
  @Field(() => GraphQLJSON, { nullable: true })
  gt?: any;
  @Field(() => GraphQLJSON, { nullable: true })
  gte?: any;
  @Field(() => GraphQLJSON, { nullable: true })
  not?: any;
}

@InputType()
export class NestedDecimalWithAggregatesFilter {
  @Field(() => GraphQLHexadecimal, { nullable: true })
  equals?: string;
  @Field(() => [GraphQLHexadecimal], { nullable: true })
  in?: string[];
  @Field(() => [GraphQLHexadecimal], { nullable: true })
  notIn?: string[];
  @Field(() => GraphQLHexadecimal, { nullable: true })
  lt?: string;
  @Field(() => GraphQLHexadecimal, { nullable: true })
  lte?: string;
  @Field(() => GraphQLHexadecimal, { nullable: true })
  gt?: string;
  @Field(() => GraphQLHexadecimal, { nullable: true })
  gte?: string;
  @Field(() => NestedDecimalWithAggregatesFilter, { nullable: true })
  not?: NestedDecimalWithAggregatesFilter;
  @Field(() => NestedIntFilter, { nullable: true })
  _count?: NestedIntFilter;
  @Field(() => NestedDecimalFilter, { nullable: true })
  _avg?: NestedDecimalFilter;
  @Field(() => NestedDecimalFilter, { nullable: true })
  _sum?: NestedDecimalFilter;
  @Field(() => NestedDecimalFilter, { nullable: true })
  _min?: NestedDecimalFilter;
  @Field(() => NestedDecimalFilter, { nullable: true })
  _max?: NestedDecimalFilter;
}

@InputType()
export class NestedFloatWithAggregatesFilter {
  @Field(() => Float, { nullable: true })
  equals?: number;
  @Field(() => [Float], { nullable: true })
  in?: number[];
  @Field(() => [Float], { nullable: true })
  notIn?: number[];
  @Field(() => Float, { nullable: true })
  lt?: number;
  @Field(() => Float, { nullable: true })
  lte?: number;
  @Field(() => Float, { nullable: true })
  gt?: number;
  @Field(() => Float, { nullable: true })
  gte?: number;
  @Field(() => NestedFloatWithAggregatesFilter, { nullable: true })
  not?: NestedFloatWithAggregatesFilter;
  @Field(() => NestedIntFilter, { nullable: true })
  _count?: NestedIntFilter;
  @Field(() => NestedFloatFilter, { nullable: true })
  _avg?: NestedFloatFilter;
  @Field(() => NestedFloatFilter, { nullable: true })
  _sum?: NestedFloatFilter;
  @Field(() => NestedFloatFilter, { nullable: true })
  _min?: NestedFloatFilter;
  @Field(() => NestedFloatFilter, { nullable: true })
  _max?: NestedFloatFilter;
}

@InputType()
export class NestedBytesWithAggregatesFilter {
  @Field(() => GraphQLByte, { nullable: true })
  equals?: Buffer;
  @Field(() => [GraphQLByte], { nullable: true })
  in?: Buffer[];
  @Field(() => [GraphQLByte], { nullable: true })
  notIn?: Buffer[];
  @Field(() => NestedBytesWithAggregatesFilter, { nullable: true })
  not?: NestedBytesWithAggregatesFilter;
  @Field(() => NestedIntFilter, { nullable: true })
  _count?: NestedIntFilter;
  @Field(() => NestedBytesFilter, { nullable: true })
  _min?: NestedBytesFilter;
  @Field(() => NestedBytesFilter, { nullable: true })
  _max?: NestedBytesFilter;
}

@InputType()
export class NestedBigIntWithAggregatesFilter {
  @Field(() => GraphQLBigInt, { nullable: true })
  equals?: bigint;
  @Field(() => [GraphQLBigInt], { nullable: true })
  in?: bigint[];
  @Field(() => [GraphQLBigInt], { nullable: true })
  notIn?: bigint[];
  @Field(() => GraphQLBigInt, { nullable: true })
  lt?: bigint;
  @Field(() => GraphQLBigInt, { nullable: true })
  lte?: bigint;
  @Field(() => GraphQLBigInt, { nullable: true })
  gt?: bigint;
  @Field(() => GraphQLBigInt, { nullable: true })
  gte?: bigint;
  @Field(() => NestedBigIntWithAggregatesFilter, { nullable: true })
  not?: NestedBigIntWithAggregatesFilter;
  @Field(() => NestedIntFilter, { nullable: true })
  _count?: NestedIntFilter;
  @Field(() => NestedFloatFilter, { nullable: true })
  _avg?: NestedFloatFilter;
  @Field(() => NestedBigIntFilter, { nullable: true })
  _sum?: NestedBigIntFilter;
  @Field(() => NestedBigIntFilter, { nullable: true })
  _min?: NestedBigIntFilter;
  @Field(() => NestedBigIntFilter, { nullable: true })
  _max?: NestedBigIntFilter;
}

@InputType()
export class PostCreateWithoutAuthorInput {
  @Field(() => Date, { nullable: true })
  createdAt?: Date;
  @Field(() => Date, { nullable: true })
  updatedAt?: Date;
  @Field(() => String, { nullable: false })
  title: string;
  @Field(() => String, { nullable: true })
  content?: string;
  @Field(() => Boolean, { nullable: true })
  published?: boolean;
  @Field(() => PostKind, { nullable: false })
  postKind: PostKind;
  @Field(() => UserCreateNestedOneWithoutAnotherPostsInput, { nullable: false })
  anotherAuthor: UserCreateNestedOneWithoutAnotherPostsInput;
  @Field(() => CategoryCreateNestedManyWithoutPostsInput, { nullable: true })
  categories?: CategoryCreateNestedManyWithoutPostsInput;
}

@InputType()
export class PostCreateOrConnectWithoutAuthorInput {
  @Field(() => PostWhereUniqueInput, { nullable: false })
  where: PostWhereUniqueInput;
  @Field(() => PostCreateWithoutAuthorInput, { nullable: false })
  create: PostCreateWithoutAuthorInput;
}

@InputType()
export class PostCreateManyAuthorInputEnvelope {
  @Field(() => [PostCreateManyAuthorInput], { nullable: false })
  data: PostCreateManyAuthorInput[];
  @Field(() => Boolean, { nullable: true })
  skipDuplicates?: boolean;
}

@InputType()
export class UserCreateWithoutChildrenInput {
  @Field(() => Date, { nullable: true })
  createdAt?: Date;
  @Field(() => Date, { nullable: true })
  updatedAt?: Date;
  @Field(() => String, { nullable: false })
  email: string;
  @Field(() => String, { nullable: true })
  name?: string;
  @Field(() => UserRole, { nullable: true })
  role?: UserRole;
  @Field(() => String, { nullable: false })
  mappedField: string;
  @Field(() => PostCreateNestedManyWithoutAuthorInput, { nullable: true })
  posts?: PostCreateNestedManyWithoutAuthorInput;
  @Field(() => UserCreateNestedOneWithoutChildrenInput, { nullable: true })
  parent?: UserCreateNestedOneWithoutChildrenInput;
  @Field(() => PostCreateNestedManyWithoutAnotherAuthorInput, {
    nullable: true,
  })
  anotherPosts?: PostCreateNestedManyWithoutAnotherAuthorInput;
  @Field(() => TagCreateNestedManyWithoutUsersInput, { nullable: true })
  tags?: TagCreateNestedManyWithoutUsersInput;
  @Field(() => ProfileCreateNestedOneWithoutUserInput, { nullable: true })
  profile?: ProfileCreateNestedOneWithoutUserInput;
}

@InputType()
export class UserCreateOrConnectWithoutChildrenInput {
  @Field(() => UserWhereUniqueInput, { nullable: false })
  where: UserWhereUniqueInput;
  @Field(() => UserCreateWithoutChildrenInput, { nullable: false })
  create: UserCreateWithoutChildrenInput;
}

@InputType()
export class UserCreateWithoutParentInput {
  @Field(() => Date, { nullable: true })
  createdAt?: Date;
  @Field(() => Date, { nullable: true })
  updatedAt?: Date;
  @Field(() => String, { nullable: false })
  email: string;
  @Field(() => String, { nullable: true })
  name?: string;
  @Field(() => UserRole, { nullable: true })
  role?: UserRole;
  @Field(() => String, { nullable: false })
  mappedField: string;
  @Field(() => PostCreateNestedManyWithoutAuthorInput, { nullable: true })
  posts?: PostCreateNestedManyWithoutAuthorInput;
  @Field(() => UserCreateNestedManyWithoutParentInput, { nullable: true })
  children?: UserCreateNestedManyWithoutParentInput;
  @Field(() => PostCreateNestedManyWithoutAnotherAuthorInput, {
    nullable: true,
  })
  anotherPosts?: PostCreateNestedManyWithoutAnotherAuthorInput;
  @Field(() => TagCreateNestedManyWithoutUsersInput, { nullable: true })
  tags?: TagCreateNestedManyWithoutUsersInput;
  @Field(() => ProfileCreateNestedOneWithoutUserInput, { nullable: true })
  profile?: ProfileCreateNestedOneWithoutUserInput;
}

@InputType()
export class UserCreateOrConnectWithoutParentInput {
  @Field(() => UserWhereUniqueInput, { nullable: false })
  where: UserWhereUniqueInput;
  @Field(() => UserCreateWithoutParentInput, { nullable: false })
  create: UserCreateWithoutParentInput;
}

@InputType()
export class UserCreateManyParentInputEnvelope {
  @Field(() => [UserCreateManyParentInput], { nullable: false })
  data: UserCreateManyParentInput[];
  @Field(() => Boolean, { nullable: true })
  skipDuplicates?: boolean;
}

@InputType()
export class PostCreateWithoutAnotherAuthorInput {
  @Field(() => Date, { nullable: true })
  createdAt?: Date;
  @Field(() => Date, { nullable: true })
  updatedAt?: Date;
  @Field(() => String, { nullable: false })
  title: string;
  @Field(() => String, { nullable: true })
  content?: string;
  @Field(() => Boolean, { nullable: true })
  published?: boolean;
  @Field(() => PostKind, { nullable: false })
  postKind: PostKind;
  @Field(() => UserCreateNestedOneWithoutPostsInput, { nullable: false })
  author: UserCreateNestedOneWithoutPostsInput;
  @Field(() => CategoryCreateNestedManyWithoutPostsInput, { nullable: true })
  categories?: CategoryCreateNestedManyWithoutPostsInput;
}

@InputType()
export class PostCreateOrConnectWithoutAnotherAuthorInput {
  @Field(() => PostWhereUniqueInput, { nullable: false })
  where: PostWhereUniqueInput;
  @Field(() => PostCreateWithoutAnotherAuthorInput, { nullable: false })
  create: PostCreateWithoutAnotherAuthorInput;
}

@InputType()
export class PostCreateManyAnotherAuthorInputEnvelope {
  @Field(() => [PostCreateManyAnotherAuthorInput], { nullable: false })
  data: PostCreateManyAnotherAuthorInput[];
  @Field(() => Boolean, { nullable: true })
  skipDuplicates?: boolean;
}

@InputType()
export class TagCreateWithoutUsersInput {
  @Field(() => String, { nullable: false })
  key: string;
}

@InputType()
export class TagCreateOrConnectWithoutUsersInput {
  @Field(() => TagWhereUniqueInput, { nullable: false })
  where: TagWhereUniqueInput;
  @Field(() => TagCreateWithoutUsersInput, { nullable: false })
  create: TagCreateWithoutUsersInput;
}

@InputType()
export class ProfileCreateWithoutUserInput {
  @Field(() => Date, { nullable: true })
  createdAt?: Date;
  @Field(() => Date, { nullable: true })
  updatedAt?: Date;
  @Field(() => String, { nullable: true })
  bio?: string;
}

@InputType()
export class ProfileCreateOrConnectWithoutUserInput {
  @Field(() => ProfileWhereUniqueInput, { nullable: false })
  where: ProfileWhereUniqueInput;
  @Field(() => ProfileCreateWithoutUserInput, { nullable: false })
  create: ProfileCreateWithoutUserInput;
}

@InputType()
export class PostUpsertWithWhereUniqueWithoutAuthorInput {
  @Field(() => PostWhereUniqueInput, { nullable: false })
  where: PostWhereUniqueInput;
  @Field(() => PostUpdateWithoutAuthorInput, { nullable: false })
  update: PostUpdateWithoutAuthorInput;
  @Field(() => PostCreateWithoutAuthorInput, { nullable: false })
  create: PostCreateWithoutAuthorInput;
}

@InputType()
export class PostUpdateWithWhereUniqueWithoutAuthorInput {
  @Field(() => PostWhereUniqueInput, { nullable: false })
  where: PostWhereUniqueInput;
  @Field(() => PostUpdateWithoutAuthorInput, { nullable: false })
  data: PostUpdateWithoutAuthorInput;
}

@InputType()
export class PostUpdateManyWithWhereWithoutAuthorInput {
  @Field(() => PostScalarWhereInput, { nullable: false })
  where: PostScalarWhereInput;
  @Field(() => PostUpdateManyMutationInput, { nullable: false })
  data: PostUpdateManyMutationInput;
}

@InputType()
export class PostScalarWhereInput {
  @Field(() => [PostScalarWhereInput], { nullable: true })
  AND?: PostScalarWhereInput[];
  @Field(() => [PostScalarWhereInput], { nullable: true })
  OR?: PostScalarWhereInput[];
  @Field(() => [PostScalarWhereInput], { nullable: true })
  NOT?: PostScalarWhereInput[];
  @Field(() => IntFilter, { nullable: true })
  id?: IntFilter;
  @Field(() => DateTimeFilter, { nullable: true })
  createdAt?: DateTimeFilter;
  @Field(() => DateTimeFilter, { nullable: true })
  updatedAt?: DateTimeFilter;
  @Field(() => StringFilter, { nullable: true })
  title?: StringFilter;
  @Field(() => StringNullableFilter, { nullable: true })
  content?: StringNullableFilter;
  @Field(() => BoolFilter, { nullable: true })
  published?: BoolFilter;
  @Field(() => IntFilter, { nullable: true })
  authorId?: IntFilter;
  @Field(() => IntFilter, { nullable: true })
  anotherAuthorId?: IntFilter;
  @Field(() => EnumPostKindFilter, { nullable: true })
  postKind?: EnumPostKindFilter;
}

@InputType()
export class UserUpsertWithoutChildrenInput {
  @Field(() => UserUpdateWithoutChildrenInput, { nullable: false })
  update: UserUpdateWithoutChildrenInput;
  @Field(() => UserCreateWithoutChildrenInput, { nullable: false })
  create: UserCreateWithoutChildrenInput;
  @Field(() => UserWhereInput, { nullable: true })
  where?: UserWhereInput;
}

@InputType()
export class UserUpdateToOneWithWhereWithoutChildrenInput {
  @Field(() => UserWhereInput, { nullable: true })
  where?: UserWhereInput;
  @Field(() => UserUpdateWithoutChildrenInput, { nullable: false })
  data: UserUpdateWithoutChildrenInput;
}

@InputType()
export class UserUpdateWithoutChildrenInput {
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  createdAt?: DateTimeFieldUpdateOperationsInput;
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  updatedAt?: DateTimeFieldUpdateOperationsInput;
  @Field(() => StringFieldUpdateOperationsInput, { nullable: true })
  email?: StringFieldUpdateOperationsInput;
  @Field(() => NullableStringFieldUpdateOperationsInput, { nullable: true })
  name?: NullableStringFieldUpdateOperationsInput;
  @Field(() => UserRole, { nullable: true })
  role?: UserRole;
  @Field(() => StringFieldUpdateOperationsInput, { nullable: true })
  mappedField?: StringFieldUpdateOperationsInput;
  @Field(() => PostUpdateManyWithoutAuthorNestedInput, { nullable: true })
  posts?: PostUpdateManyWithoutAuthorNestedInput;
  @Field(() => UserUpdateOneWithoutChildrenNestedInput, { nullable: true })
  parent?: UserUpdateOneWithoutChildrenNestedInput;
  @Field(() => PostUpdateManyWithoutAnotherAuthorNestedInput, {
    nullable: true,
  })
  anotherPosts?: PostUpdateManyWithoutAnotherAuthorNestedInput;
  @Field(() => TagUpdateManyWithoutUsersNestedInput, { nullable: true })
  tags?: TagUpdateManyWithoutUsersNestedInput;
  @Field(() => ProfileUpdateOneWithoutUserNestedInput, { nullable: true })
  profile?: ProfileUpdateOneWithoutUserNestedInput;
}

@InputType()
export class UserUpsertWithWhereUniqueWithoutParentInput {
  @Field(() => UserWhereUniqueInput, { nullable: false })
  where: UserWhereUniqueInput;
  @Field(() => UserUpdateWithoutParentInput, { nullable: false })
  update: UserUpdateWithoutParentInput;
  @Field(() => UserCreateWithoutParentInput, { nullable: false })
  create: UserCreateWithoutParentInput;
}

@InputType()
export class UserUpdateWithWhereUniqueWithoutParentInput {
  @Field(() => UserWhereUniqueInput, { nullable: false })
  where: UserWhereUniqueInput;
  @Field(() => UserUpdateWithoutParentInput, { nullable: false })
  data: UserUpdateWithoutParentInput;
}

@InputType()
export class UserUpdateManyWithWhereWithoutParentInput {
  @Field(() => UserScalarWhereInput, { nullable: false })
  where: UserScalarWhereInput;
  @Field(() => UserUpdateManyMutationInput, { nullable: false })
  data: UserUpdateManyMutationInput;
}

@InputType()
export class UserScalarWhereInput {
  @Field(() => [UserScalarWhereInput], { nullable: true })
  AND?: UserScalarWhereInput[];
  @Field(() => [UserScalarWhereInput], { nullable: true })
  OR?: UserScalarWhereInput[];
  @Field(() => [UserScalarWhereInput], { nullable: true })
  NOT?: UserScalarWhereInput[];
  @Field(() => IntFilter, { nullable: true })
  id?: IntFilter;
  @Field(() => DateTimeFilter, { nullable: true })
  createdAt?: DateTimeFilter;
  @Field(() => DateTimeFilter, { nullable: true })
  updatedAt?: DateTimeFilter;
  @Field(() => StringFilter, { nullable: true })
  email?: StringFilter;
  @Field(() => StringNullableFilter, { nullable: true })
  name?: StringNullableFilter;
  @Field(() => EnumUserRoleFilter, { nullable: true })
  role?: EnumUserRoleFilter;
  @Field(() => IntNullableFilter, { nullable: true })
  parentId?: IntNullableFilter;
  @Field(() => StringFilter, { nullable: true })
  mappedField?: StringFilter;
}

@InputType()
export class PostUpsertWithWhereUniqueWithoutAnotherAuthorInput {
  @Field(() => PostWhereUniqueInput, { nullable: false })
  where: PostWhereUniqueInput;
  @Field(() => PostUpdateWithoutAnotherAuthorInput, { nullable: false })
  update: PostUpdateWithoutAnotherAuthorInput;
  @Field(() => PostCreateWithoutAnotherAuthorInput, { nullable: false })
  create: PostCreateWithoutAnotherAuthorInput;
}

@InputType()
export class PostUpdateWithWhereUniqueWithoutAnotherAuthorInput {
  @Field(() => PostWhereUniqueInput, { nullable: false })
  where: PostWhereUniqueInput;
  @Field(() => PostUpdateWithoutAnotherAuthorInput, { nullable: false })
  data: PostUpdateWithoutAnotherAuthorInput;
}

@InputType()
export class PostUpdateManyWithWhereWithoutAnotherAuthorInput {
  @Field(() => PostScalarWhereInput, { nullable: false })
  where: PostScalarWhereInput;
  @Field(() => PostUpdateManyMutationInput, { nullable: false })
  data: PostUpdateManyMutationInput;
}

@InputType()
export class TagUpsertWithWhereUniqueWithoutUsersInput {
  @Field(() => TagWhereUniqueInput, { nullable: false })
  where: TagWhereUniqueInput;
  @Field(() => TagUpdateWithoutUsersInput, { nullable: false })
  update: TagUpdateWithoutUsersInput;
  @Field(() => TagCreateWithoutUsersInput, { nullable: false })
  create: TagCreateWithoutUsersInput;
}

@InputType()
export class TagUpdateWithWhereUniqueWithoutUsersInput {
  @Field(() => TagWhereUniqueInput, { nullable: false })
  where: TagWhereUniqueInput;
  @Field(() => TagUpdateWithoutUsersInput, { nullable: false })
  data: TagUpdateWithoutUsersInput;
}

@InputType()
export class TagUpdateManyWithWhereWithoutUsersInput {
  @Field(() => TagScalarWhereInput, { nullable: false })
  where: TagScalarWhereInput;
  @Field(() => TagUpdateManyMutationInput, { nullable: false })
  data: TagUpdateManyMutationInput;
}

@InputType()
export class TagScalarWhereInput {
  @Field(() => [TagScalarWhereInput], { nullable: true })
  AND?: TagScalarWhereInput[];
  @Field(() => [TagScalarWhereInput], { nullable: true })
  OR?: TagScalarWhereInput[];
  @Field(() => [TagScalarWhereInput], { nullable: true })
  NOT?: TagScalarWhereInput[];
  @Field(() => StringFilter, { nullable: true })
  key?: StringFilter;
}

@InputType()
export class ProfileUpsertWithoutUserInput {
  @Field(() => ProfileUpdateWithoutUserInput, { nullable: false })
  update: ProfileUpdateWithoutUserInput;
  @Field(() => ProfileCreateWithoutUserInput, { nullable: false })
  create: ProfileCreateWithoutUserInput;
  @Field(() => ProfileWhereInput, { nullable: true })
  where?: ProfileWhereInput;
}

@InputType()
export class ProfileUpdateToOneWithWhereWithoutUserInput {
  @Field(() => ProfileWhereInput, { nullable: true })
  where?: ProfileWhereInput;
  @Field(() => ProfileUpdateWithoutUserInput, { nullable: false })
  data: ProfileUpdateWithoutUserInput;
}

@InputType()
export class ProfileUpdateWithoutUserInput {
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  createdAt?: DateTimeFieldUpdateOperationsInput;
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  updatedAt?: DateTimeFieldUpdateOperationsInput;
  @Field(() => NullableStringFieldUpdateOperationsInput, { nullable: true })
  bio?: NullableStringFieldUpdateOperationsInput;
}

@InputType()
export class UserCreateWithoutProfileInput {
  @Field(() => Date, { nullable: true })
  createdAt?: Date;
  @Field(() => Date, { nullable: true })
  updatedAt?: Date;
  @Field(() => String, { nullable: false })
  email: string;
  @Field(() => String, { nullable: true })
  name?: string;
  @Field(() => UserRole, { nullable: true })
  role?: UserRole;
  @Field(() => String, { nullable: false })
  mappedField: string;
  @Field(() => PostCreateNestedManyWithoutAuthorInput, { nullable: true })
  posts?: PostCreateNestedManyWithoutAuthorInput;
  @Field(() => UserCreateNestedOneWithoutChildrenInput, { nullable: true })
  parent?: UserCreateNestedOneWithoutChildrenInput;
  @Field(() => UserCreateNestedManyWithoutParentInput, { nullable: true })
  children?: UserCreateNestedManyWithoutParentInput;
  @Field(() => PostCreateNestedManyWithoutAnotherAuthorInput, {
    nullable: true,
  })
  anotherPosts?: PostCreateNestedManyWithoutAnotherAuthorInput;
  @Field(() => TagCreateNestedManyWithoutUsersInput, { nullable: true })
  tags?: TagCreateNestedManyWithoutUsersInput;
}

@InputType()
export class UserCreateOrConnectWithoutProfileInput {
  @Field(() => UserWhereUniqueInput, { nullable: false })
  where: UserWhereUniqueInput;
  @Field(() => UserCreateWithoutProfileInput, { nullable: false })
  create: UserCreateWithoutProfileInput;
}

@InputType()
export class UserUpsertWithoutProfileInput {
  @Field(() => UserUpdateWithoutProfileInput, { nullable: false })
  update: UserUpdateWithoutProfileInput;
  @Field(() => UserCreateWithoutProfileInput, { nullable: false })
  create: UserCreateWithoutProfileInput;
  @Field(() => UserWhereInput, { nullable: true })
  where?: UserWhereInput;
}

@InputType()
export class UserUpdateToOneWithWhereWithoutProfileInput {
  @Field(() => UserWhereInput, { nullable: true })
  where?: UserWhereInput;
  @Field(() => UserUpdateWithoutProfileInput, { nullable: false })
  data: UserUpdateWithoutProfileInput;
}

@InputType()
export class UserUpdateWithoutProfileInput {
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  createdAt?: DateTimeFieldUpdateOperationsInput;
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  updatedAt?: DateTimeFieldUpdateOperationsInput;
  @Field(() => StringFieldUpdateOperationsInput, { nullable: true })
  email?: StringFieldUpdateOperationsInput;
  @Field(() => NullableStringFieldUpdateOperationsInput, { nullable: true })
  name?: NullableStringFieldUpdateOperationsInput;
  @Field(() => UserRole, { nullable: true })
  role?: UserRole;
  @Field(() => StringFieldUpdateOperationsInput, { nullable: true })
  mappedField?: StringFieldUpdateOperationsInput;
  @Field(() => PostUpdateManyWithoutAuthorNestedInput, { nullable: true })
  posts?: PostUpdateManyWithoutAuthorNestedInput;
  @Field(() => UserUpdateOneWithoutChildrenNestedInput, { nullable: true })
  parent?: UserUpdateOneWithoutChildrenNestedInput;
  @Field(() => UserUpdateManyWithoutParentNestedInput, { nullable: true })
  children?: UserUpdateManyWithoutParentNestedInput;
  @Field(() => PostUpdateManyWithoutAnotherAuthorNestedInput, {
    nullable: true,
  })
  anotherPosts?: PostUpdateManyWithoutAnotherAuthorNestedInput;
  @Field(() => TagUpdateManyWithoutUsersNestedInput, { nullable: true })
  tags?: TagUpdateManyWithoutUsersNestedInput;
}

@InputType()
export class UserCreateWithoutPostsInput {
  @Field(() => Date, { nullable: true })
  createdAt?: Date;
  @Field(() => Date, { nullable: true })
  updatedAt?: Date;
  @Field(() => String, { nullable: false })
  email: string;
  @Field(() => String, { nullable: true })
  name?: string;
  @Field(() => UserRole, { nullable: true })
  role?: UserRole;
  @Field(() => String, { nullable: false })
  mappedField: string;
  @Field(() => UserCreateNestedOneWithoutChildrenInput, { nullable: true })
  parent?: UserCreateNestedOneWithoutChildrenInput;
  @Field(() => UserCreateNestedManyWithoutParentInput, { nullable: true })
  children?: UserCreateNestedManyWithoutParentInput;
  @Field(() => PostCreateNestedManyWithoutAnotherAuthorInput, {
    nullable: true,
  })
  anotherPosts?: PostCreateNestedManyWithoutAnotherAuthorInput;
  @Field(() => TagCreateNestedManyWithoutUsersInput, { nullable: true })
  tags?: TagCreateNestedManyWithoutUsersInput;
  @Field(() => ProfileCreateNestedOneWithoutUserInput, { nullable: true })
  profile?: ProfileCreateNestedOneWithoutUserInput;
}

@InputType()
export class UserCreateOrConnectWithoutPostsInput {
  @Field(() => UserWhereUniqueInput, { nullable: false })
  where: UserWhereUniqueInput;
  @Field(() => UserCreateWithoutPostsInput, { nullable: false })
  create: UserCreateWithoutPostsInput;
}

@InputType()
export class UserCreateWithoutAnotherPostsInput {
  @Field(() => Date, { nullable: true })
  createdAt?: Date;
  @Field(() => Date, { nullable: true })
  updatedAt?: Date;
  @Field(() => String, { nullable: false })
  email: string;
  @Field(() => String, { nullable: true })
  name?: string;
  @Field(() => UserRole, { nullable: true })
  role?: UserRole;
  @Field(() => String, { nullable: false })
  mappedField: string;
  @Field(() => PostCreateNestedManyWithoutAuthorInput, { nullable: true })
  posts?: PostCreateNestedManyWithoutAuthorInput;
  @Field(() => UserCreateNestedOneWithoutChildrenInput, { nullable: true })
  parent?: UserCreateNestedOneWithoutChildrenInput;
  @Field(() => UserCreateNestedManyWithoutParentInput, { nullable: true })
  children?: UserCreateNestedManyWithoutParentInput;
  @Field(() => TagCreateNestedManyWithoutUsersInput, { nullable: true })
  tags?: TagCreateNestedManyWithoutUsersInput;
  @Field(() => ProfileCreateNestedOneWithoutUserInput, { nullable: true })
  profile?: ProfileCreateNestedOneWithoutUserInput;
}

@InputType()
export class UserCreateOrConnectWithoutAnotherPostsInput {
  @Field(() => UserWhereUniqueInput, { nullable: false })
  where: UserWhereUniqueInput;
  @Field(() => UserCreateWithoutAnotherPostsInput, { nullable: false })
  create: UserCreateWithoutAnotherPostsInput;
}

@InputType()
export class CategoryCreateWithoutPostsInput {
  @Field(() => Date, { nullable: true })
  createdAt?: Date;
  @Field(() => Date, { nullable: true })
  updatedAt?: Date;
  @Field(() => String, { nullable: false })
  name: string;
  @Field(() => CategoryMetadataCreateNestedOneWithoutCategoryInput, {
    nullable: true,
  })
  metadata?: CategoryMetadataCreateNestedOneWithoutCategoryInput;
}

@InputType()
export class CategoryCreateOrConnectWithoutPostsInput {
  @Field(() => CategoryWhereUniqueInput, { nullable: false })
  where: CategoryWhereUniqueInput;
  @Field(() => CategoryCreateWithoutPostsInput, { nullable: false })
  create: CategoryCreateWithoutPostsInput;
}

@InputType()
export class UserUpsertWithoutPostsInput {
  @Field(() => UserUpdateWithoutPostsInput, { nullable: false })
  update: UserUpdateWithoutPostsInput;
  @Field(() => UserCreateWithoutPostsInput, { nullable: false })
  create: UserCreateWithoutPostsInput;
  @Field(() => UserWhereInput, { nullable: true })
  where?: UserWhereInput;
}

@InputType()
export class UserUpdateToOneWithWhereWithoutPostsInput {
  @Field(() => UserWhereInput, { nullable: true })
  where?: UserWhereInput;
  @Field(() => UserUpdateWithoutPostsInput, { nullable: false })
  data: UserUpdateWithoutPostsInput;
}

@InputType()
export class UserUpdateWithoutPostsInput {
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  createdAt?: DateTimeFieldUpdateOperationsInput;
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  updatedAt?: DateTimeFieldUpdateOperationsInput;
  @Field(() => StringFieldUpdateOperationsInput, { nullable: true })
  email?: StringFieldUpdateOperationsInput;
  @Field(() => NullableStringFieldUpdateOperationsInput, { nullable: true })
  name?: NullableStringFieldUpdateOperationsInput;
  @Field(() => UserRole, { nullable: true })
  role?: UserRole;
  @Field(() => StringFieldUpdateOperationsInput, { nullable: true })
  mappedField?: StringFieldUpdateOperationsInput;
  @Field(() => UserUpdateOneWithoutChildrenNestedInput, { nullable: true })
  parent?: UserUpdateOneWithoutChildrenNestedInput;
  @Field(() => UserUpdateManyWithoutParentNestedInput, { nullable: true })
  children?: UserUpdateManyWithoutParentNestedInput;
  @Field(() => PostUpdateManyWithoutAnotherAuthorNestedInput, {
    nullable: true,
  })
  anotherPosts?: PostUpdateManyWithoutAnotherAuthorNestedInput;
  @Field(() => TagUpdateManyWithoutUsersNestedInput, { nullable: true })
  tags?: TagUpdateManyWithoutUsersNestedInput;
  @Field(() => ProfileUpdateOneWithoutUserNestedInput, { nullable: true })
  profile?: ProfileUpdateOneWithoutUserNestedInput;
}

@InputType()
export class UserUpsertWithoutAnotherPostsInput {
  @Field(() => UserUpdateWithoutAnotherPostsInput, { nullable: false })
  update: UserUpdateWithoutAnotherPostsInput;
  @Field(() => UserCreateWithoutAnotherPostsInput, { nullable: false })
  create: UserCreateWithoutAnotherPostsInput;
  @Field(() => UserWhereInput, { nullable: true })
  where?: UserWhereInput;
}

@InputType()
export class UserUpdateToOneWithWhereWithoutAnotherPostsInput {
  @Field(() => UserWhereInput, { nullable: true })
  where?: UserWhereInput;
  @Field(() => UserUpdateWithoutAnotherPostsInput, { nullable: false })
  data: UserUpdateWithoutAnotherPostsInput;
}

@InputType()
export class UserUpdateWithoutAnotherPostsInput {
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  createdAt?: DateTimeFieldUpdateOperationsInput;
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  updatedAt?: DateTimeFieldUpdateOperationsInput;
  @Field(() => StringFieldUpdateOperationsInput, { nullable: true })
  email?: StringFieldUpdateOperationsInput;
  @Field(() => NullableStringFieldUpdateOperationsInput, { nullable: true })
  name?: NullableStringFieldUpdateOperationsInput;
  @Field(() => UserRole, { nullable: true })
  role?: UserRole;
  @Field(() => StringFieldUpdateOperationsInput, { nullable: true })
  mappedField?: StringFieldUpdateOperationsInput;
  @Field(() => PostUpdateManyWithoutAuthorNestedInput, { nullable: true })
  posts?: PostUpdateManyWithoutAuthorNestedInput;
  @Field(() => UserUpdateOneWithoutChildrenNestedInput, { nullable: true })
  parent?: UserUpdateOneWithoutChildrenNestedInput;
  @Field(() => UserUpdateManyWithoutParentNestedInput, { nullable: true })
  children?: UserUpdateManyWithoutParentNestedInput;
  @Field(() => TagUpdateManyWithoutUsersNestedInput, { nullable: true })
  tags?: TagUpdateManyWithoutUsersNestedInput;
  @Field(() => ProfileUpdateOneWithoutUserNestedInput, { nullable: true })
  profile?: ProfileUpdateOneWithoutUserNestedInput;
}

@InputType()
export class CategoryUpsertWithWhereUniqueWithoutPostsInput {
  @Field(() => CategoryWhereUniqueInput, { nullable: false })
  where: CategoryWhereUniqueInput;
  @Field(() => CategoryUpdateWithoutPostsInput, { nullable: false })
  update: CategoryUpdateWithoutPostsInput;
  @Field(() => CategoryCreateWithoutPostsInput, { nullable: false })
  create: CategoryCreateWithoutPostsInput;
}

@InputType()
export class CategoryUpdateWithWhereUniqueWithoutPostsInput {
  @Field(() => CategoryWhereUniqueInput, { nullable: false })
  where: CategoryWhereUniqueInput;
  @Field(() => CategoryUpdateWithoutPostsInput, { nullable: false })
  data: CategoryUpdateWithoutPostsInput;
}

@InputType()
export class CategoryUpdateManyWithWhereWithoutPostsInput {
  @Field(() => CategoryScalarWhereInput, { nullable: false })
  where: CategoryScalarWhereInput;
  @Field(() => CategoryUpdateManyMutationInput, { nullable: false })
  data: CategoryUpdateManyMutationInput;
}

@InputType()
export class CategoryScalarWhereInput {
  @Field(() => [CategoryScalarWhereInput], { nullable: true })
  AND?: CategoryScalarWhereInput[];
  @Field(() => [CategoryScalarWhereInput], { nullable: true })
  OR?: CategoryScalarWhereInput[];
  @Field(() => [CategoryScalarWhereInput], { nullable: true })
  NOT?: CategoryScalarWhereInput[];
  @Field(() => IntFilter, { nullable: true })
  id?: IntFilter;
  @Field(() => DateTimeFilter, { nullable: true })
  createdAt?: DateTimeFilter;
  @Field(() => DateTimeFilter, { nullable: true })
  updatedAt?: DateTimeFilter;
  @Field(() => StringFilter, { nullable: true })
  name?: StringFilter;
}

@InputType()
export class UserCreateWithoutTagsInput {
  @Field(() => Date, { nullable: true })
  createdAt?: Date;
  @Field(() => Date, { nullable: true })
  updatedAt?: Date;
  @Field(() => String, { nullable: false })
  email: string;
  @Field(() => String, { nullable: true })
  name?: string;
  @Field(() => UserRole, { nullable: true })
  role?: UserRole;
  @Field(() => String, { nullable: false })
  mappedField: string;
  @Field(() => PostCreateNestedManyWithoutAuthorInput, { nullable: true })
  posts?: PostCreateNestedManyWithoutAuthorInput;
  @Field(() => UserCreateNestedOneWithoutChildrenInput, { nullable: true })
  parent?: UserCreateNestedOneWithoutChildrenInput;
  @Field(() => UserCreateNestedManyWithoutParentInput, { nullable: true })
  children?: UserCreateNestedManyWithoutParentInput;
  @Field(() => PostCreateNestedManyWithoutAnotherAuthorInput, {
    nullable: true,
  })
  anotherPosts?: PostCreateNestedManyWithoutAnotherAuthorInput;
  @Field(() => ProfileCreateNestedOneWithoutUserInput, { nullable: true })
  profile?: ProfileCreateNestedOneWithoutUserInput;
}

@InputType()
export class UserCreateOrConnectWithoutTagsInput {
  @Field(() => UserWhereUniqueInput, { nullable: false })
  where: UserWhereUniqueInput;
  @Field(() => UserCreateWithoutTagsInput, { nullable: false })
  create: UserCreateWithoutTagsInput;
}

@InputType()
export class UserUpsertWithWhereUniqueWithoutTagsInput {
  @Field(() => UserWhereUniqueInput, { nullable: false })
  where: UserWhereUniqueInput;
  @Field(() => UserUpdateWithoutTagsInput, { nullable: false })
  update: UserUpdateWithoutTagsInput;
  @Field(() => UserCreateWithoutTagsInput, { nullable: false })
  create: UserCreateWithoutTagsInput;
}

@InputType()
export class UserUpdateWithWhereUniqueWithoutTagsInput {
  @Field(() => UserWhereUniqueInput, { nullable: false })
  where: UserWhereUniqueInput;
  @Field(() => UserUpdateWithoutTagsInput, { nullable: false })
  data: UserUpdateWithoutTagsInput;
}

@InputType()
export class UserUpdateManyWithWhereWithoutTagsInput {
  @Field(() => UserScalarWhereInput, { nullable: false })
  where: UserScalarWhereInput;
  @Field(() => UserUpdateManyMutationInput, { nullable: false })
  data: UserUpdateManyMutationInput;
}

@InputType()
export class PostCreateWithoutCategoriesInput {
  @Field(() => Date, { nullable: true })
  createdAt?: Date;
  @Field(() => Date, { nullable: true })
  updatedAt?: Date;
  @Field(() => String, { nullable: false })
  title: string;
  @Field(() => String, { nullable: true })
  content?: string;
  @Field(() => Boolean, { nullable: true })
  published?: boolean;
  @Field(() => PostKind, { nullable: false })
  postKind: PostKind;
  @Field(() => UserCreateNestedOneWithoutPostsInput, { nullable: false })
  author: UserCreateNestedOneWithoutPostsInput;
  @Field(() => UserCreateNestedOneWithoutAnotherPostsInput, { nullable: false })
  anotherAuthor: UserCreateNestedOneWithoutAnotherPostsInput;
}

@InputType()
export class PostCreateOrConnectWithoutCategoriesInput {
  @Field(() => PostWhereUniqueInput, { nullable: false })
  where: PostWhereUniqueInput;
  @Field(() => PostCreateWithoutCategoriesInput, { nullable: false })
  create: PostCreateWithoutCategoriesInput;
}

@InputType()
export class CategoryMetadataCreateWithoutCategoryInput {
  @Field(() => Date, { nullable: true })
  createdAt?: Date;
  @Field(() => Date, { nullable: true })
  updatedAt?: Date;
  @Field(() => CategoryMetadataCreatemetadataInput, { nullable: true })
  metadata?: CategoryMetadataCreatemetadataInput;
}

@InputType()
export class CategoryMetadataCreateOrConnectWithoutCategoryInput {
  @Field(() => CategoryMetadataWhereUniqueInput, { nullable: false })
  where: CategoryMetadataWhereUniqueInput;
  @Field(() => CategoryMetadataCreateWithoutCategoryInput, { nullable: false })
  create: CategoryMetadataCreateWithoutCategoryInput;
}

@InputType()
export class PostUpsertWithWhereUniqueWithoutCategoriesInput {
  @Field(() => PostWhereUniqueInput, { nullable: false })
  where: PostWhereUniqueInput;
  @Field(() => PostUpdateWithoutCategoriesInput, { nullable: false })
  update: PostUpdateWithoutCategoriesInput;
  @Field(() => PostCreateWithoutCategoriesInput, { nullable: false })
  create: PostCreateWithoutCategoriesInput;
}

@InputType()
export class PostUpdateWithWhereUniqueWithoutCategoriesInput {
  @Field(() => PostWhereUniqueInput, { nullable: false })
  where: PostWhereUniqueInput;
  @Field(() => PostUpdateWithoutCategoriesInput, { nullable: false })
  data: PostUpdateWithoutCategoriesInput;
}

@InputType()
export class PostUpdateManyWithWhereWithoutCategoriesInput {
  @Field(() => PostScalarWhereInput, { nullable: false })
  where: PostScalarWhereInput;
  @Field(() => PostUpdateManyMutationInput, { nullable: false })
  data: PostUpdateManyMutationInput;
}

@InputType()
export class CategoryMetadataUpsertWithoutCategoryInput {
  @Field(() => CategoryMetadataUpdateWithoutCategoryInput, { nullable: false })
  update: CategoryMetadataUpdateWithoutCategoryInput;
  @Field(() => CategoryMetadataCreateWithoutCategoryInput, { nullable: false })
  create: CategoryMetadataCreateWithoutCategoryInput;
  @Field(() => CategoryMetadataWhereInput, { nullable: true })
  where?: CategoryMetadataWhereInput;
}

@InputType()
export class CategoryMetadataUpdateToOneWithWhereWithoutCategoryInput {
  @Field(() => CategoryMetadataWhereInput, { nullable: true })
  where?: CategoryMetadataWhereInput;
  @Field(() => CategoryMetadataUpdateWithoutCategoryInput, { nullable: false })
  data: CategoryMetadataUpdateWithoutCategoryInput;
}

@InputType()
export class CategoryMetadataUpdateWithoutCategoryInput {
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  createdAt?: DateTimeFieldUpdateOperationsInput;
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  updatedAt?: DateTimeFieldUpdateOperationsInput;
  @Field(() => CategoryMetadataUpdatemetadataInput, { nullable: true })
  metadata?: CategoryMetadataUpdatemetadataInput;
}

@InputType()
export class CategoryCreateWithoutMetadataInput {
  @Field(() => Date, { nullable: true })
  createdAt?: Date;
  @Field(() => Date, { nullable: true })
  updatedAt?: Date;
  @Field(() => String, { nullable: false })
  name: string;
  @Field(() => PostCreateNestedManyWithoutCategoriesInput, { nullable: true })
  posts?: PostCreateNestedManyWithoutCategoriesInput;
}

@InputType()
export class CategoryCreateOrConnectWithoutMetadataInput {
  @Field(() => CategoryWhereUniqueInput, { nullable: false })
  where: CategoryWhereUniqueInput;
  @Field(() => CategoryCreateWithoutMetadataInput, { nullable: false })
  create: CategoryCreateWithoutMetadataInput;
}

@InputType()
export class CategoryUpsertWithoutMetadataInput {
  @Field(() => CategoryUpdateWithoutMetadataInput, { nullable: false })
  update: CategoryUpdateWithoutMetadataInput;
  @Field(() => CategoryCreateWithoutMetadataInput, { nullable: false })
  create: CategoryCreateWithoutMetadataInput;
  @Field(() => CategoryWhereInput, { nullable: true })
  where?: CategoryWhereInput;
}

@InputType()
export class CategoryUpdateToOneWithWhereWithoutMetadataInput {
  @Field(() => CategoryWhereInput, { nullable: true })
  where?: CategoryWhereInput;
  @Field(() => CategoryUpdateWithoutMetadataInput, { nullable: false })
  data: CategoryUpdateWithoutMetadataInput;
}

@InputType()
export class CategoryUpdateWithoutMetadataInput {
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  createdAt?: DateTimeFieldUpdateOperationsInput;
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  updatedAt?: DateTimeFieldUpdateOperationsInput;
  @Field(() => StringFieldUpdateOperationsInput, { nullable: true })
  name?: StringFieldUpdateOperationsInput;
  @Field(() => PostUpdateManyWithoutCategoriesNestedInput, { nullable: true })
  posts?: PostUpdateManyWithoutCategoriesNestedInput;
}

@InputType()
export class PostCreateManyAuthorInput {
  @Field(() => Int, { nullable: true })
  id?: number;
  @Field(() => Date, { nullable: true })
  createdAt?: Date;
  @Field(() => Date, { nullable: true })
  updatedAt?: Date;
  @Field(() => String, { nullable: false })
  title: string;
  @Field(() => String, { nullable: true })
  content?: string;
  @Field(() => Boolean, { nullable: true })
  published?: boolean;
  @Field(() => Int, { nullable: false })
  anotherAuthorId: number;
  @Field(() => PostKind, { nullable: false })
  postKind: PostKind;
}

@InputType()
export class UserCreateManyParentInput {
  @Field(() => Int, { nullable: true })
  id?: number;
  @Field(() => Date, { nullable: true })
  createdAt?: Date;
  @Field(() => Date, { nullable: true })
  updatedAt?: Date;
  @Field(() => String, { nullable: false })
  email: string;
  @Field(() => String, { nullable: true })
  name?: string;
  @Field(() => UserRole, { nullable: true })
  role?: UserRole;
  @Field(() => String, { nullable: false })
  mappedField: string;
}

@InputType()
export class PostCreateManyAnotherAuthorInput {
  @Field(() => Int, { nullable: true })
  id?: number;
  @Field(() => Date, { nullable: true })
  createdAt?: Date;
  @Field(() => Date, { nullable: true })
  updatedAt?: Date;
  @Field(() => String, { nullable: false })
  title: string;
  @Field(() => String, { nullable: true })
  content?: string;
  @Field(() => Boolean, { nullable: true })
  published?: boolean;
  @Field(() => Int, { nullable: false })
  authorId: number;
  @Field(() => PostKind, { nullable: false })
  postKind: PostKind;
}

@InputType()
export class PostUpdateWithoutAuthorInput {
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  createdAt?: DateTimeFieldUpdateOperationsInput;
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  updatedAt?: DateTimeFieldUpdateOperationsInput;
  @Field(() => StringFieldUpdateOperationsInput, { nullable: true })
  title?: StringFieldUpdateOperationsInput;
  @Field(() => NullableStringFieldUpdateOperationsInput, { nullable: true })
  content?: NullableStringFieldUpdateOperationsInput;
  @Field(() => BoolFieldUpdateOperationsInput, { nullable: true })
  published?: BoolFieldUpdateOperationsInput;
  @Field(() => PostKind, { nullable: true })
  postKind?: PostKind;
  @Field(() => UserUpdateOneRequiredWithoutAnotherPostsNestedInput, {
    nullable: true,
  })
  anotherAuthor?: UserUpdateOneRequiredWithoutAnotherPostsNestedInput;
  @Field(() => CategoryUpdateManyWithoutPostsNestedInput, { nullable: true })
  categories?: CategoryUpdateManyWithoutPostsNestedInput;
}

@InputType()
export class UserUpdateWithoutParentInput {
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  createdAt?: DateTimeFieldUpdateOperationsInput;
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  updatedAt?: DateTimeFieldUpdateOperationsInput;
  @Field(() => StringFieldUpdateOperationsInput, { nullable: true })
  email?: StringFieldUpdateOperationsInput;
  @Field(() => NullableStringFieldUpdateOperationsInput, { nullable: true })
  name?: NullableStringFieldUpdateOperationsInput;
  @Field(() => UserRole, { nullable: true })
  role?: UserRole;
  @Field(() => StringFieldUpdateOperationsInput, { nullable: true })
  mappedField?: StringFieldUpdateOperationsInput;
  @Field(() => PostUpdateManyWithoutAuthorNestedInput, { nullable: true })
  posts?: PostUpdateManyWithoutAuthorNestedInput;
  @Field(() => UserUpdateManyWithoutParentNestedInput, { nullable: true })
  children?: UserUpdateManyWithoutParentNestedInput;
  @Field(() => PostUpdateManyWithoutAnotherAuthorNestedInput, {
    nullable: true,
  })
  anotherPosts?: PostUpdateManyWithoutAnotherAuthorNestedInput;
  @Field(() => TagUpdateManyWithoutUsersNestedInput, { nullable: true })
  tags?: TagUpdateManyWithoutUsersNestedInput;
  @Field(() => ProfileUpdateOneWithoutUserNestedInput, { nullable: true })
  profile?: ProfileUpdateOneWithoutUserNestedInput;
}

@InputType()
export class PostUpdateWithoutAnotherAuthorInput {
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  createdAt?: DateTimeFieldUpdateOperationsInput;
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  updatedAt?: DateTimeFieldUpdateOperationsInput;
  @Field(() => StringFieldUpdateOperationsInput, { nullable: true })
  title?: StringFieldUpdateOperationsInput;
  @Field(() => NullableStringFieldUpdateOperationsInput, { nullable: true })
  content?: NullableStringFieldUpdateOperationsInput;
  @Field(() => BoolFieldUpdateOperationsInput, { nullable: true })
  published?: BoolFieldUpdateOperationsInput;
  @Field(() => PostKind, { nullable: true })
  postKind?: PostKind;
  @Field(() => UserUpdateOneRequiredWithoutPostsNestedInput, { nullable: true })
  author?: UserUpdateOneRequiredWithoutPostsNestedInput;
  @Field(() => CategoryUpdateManyWithoutPostsNestedInput, { nullable: true })
  categories?: CategoryUpdateManyWithoutPostsNestedInput;
}

@InputType()
export class TagUpdateWithoutUsersInput {
  @Field(() => StringFieldUpdateOperationsInput, { nullable: true })
  key?: StringFieldUpdateOperationsInput;
}

@InputType()
export class CategoryUpdateWithoutPostsInput {
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  createdAt?: DateTimeFieldUpdateOperationsInput;
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  updatedAt?: DateTimeFieldUpdateOperationsInput;
  @Field(() => StringFieldUpdateOperationsInput, { nullable: true })
  name?: StringFieldUpdateOperationsInput;
  @Field(() => CategoryMetadataUpdateOneWithoutCategoryNestedInput, {
    nullable: true,
  })
  metadata?: CategoryMetadataUpdateOneWithoutCategoryNestedInput;
}

@InputType()
export class UserUpdateWithoutTagsInput {
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  createdAt?: DateTimeFieldUpdateOperationsInput;
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  updatedAt?: DateTimeFieldUpdateOperationsInput;
  @Field(() => StringFieldUpdateOperationsInput, { nullable: true })
  email?: StringFieldUpdateOperationsInput;
  @Field(() => NullableStringFieldUpdateOperationsInput, { nullable: true })
  name?: NullableStringFieldUpdateOperationsInput;
  @Field(() => UserRole, { nullable: true })
  role?: UserRole;
  @Field(() => StringFieldUpdateOperationsInput, { nullable: true })
  mappedField?: StringFieldUpdateOperationsInput;
  @Field(() => PostUpdateManyWithoutAuthorNestedInput, { nullable: true })
  posts?: PostUpdateManyWithoutAuthorNestedInput;
  @Field(() => UserUpdateOneWithoutChildrenNestedInput, { nullable: true })
  parent?: UserUpdateOneWithoutChildrenNestedInput;
  @Field(() => UserUpdateManyWithoutParentNestedInput, { nullable: true })
  children?: UserUpdateManyWithoutParentNestedInput;
  @Field(() => PostUpdateManyWithoutAnotherAuthorNestedInput, {
    nullable: true,
  })
  anotherPosts?: PostUpdateManyWithoutAnotherAuthorNestedInput;
  @Field(() => ProfileUpdateOneWithoutUserNestedInput, { nullable: true })
  profile?: ProfileUpdateOneWithoutUserNestedInput;
}

@InputType()
export class PostUpdateWithoutCategoriesInput {
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  createdAt?: DateTimeFieldUpdateOperationsInput;
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  updatedAt?: DateTimeFieldUpdateOperationsInput;
  @Field(() => StringFieldUpdateOperationsInput, { nullable: true })
  title?: StringFieldUpdateOperationsInput;
  @Field(() => NullableStringFieldUpdateOperationsInput, { nullable: true })
  content?: NullableStringFieldUpdateOperationsInput;
  @Field(() => BoolFieldUpdateOperationsInput, { nullable: true })
  published?: BoolFieldUpdateOperationsInput;
  @Field(() => PostKind, { nullable: true })
  postKind?: PostKind;
  @Field(() => UserUpdateOneRequiredWithoutPostsNestedInput, { nullable: true })
  author?: UserUpdateOneRequiredWithoutPostsNestedInput;
  @Field(() => UserUpdateOneRequiredWithoutAnotherPostsNestedInput, {
    nullable: true,
  })
  anotherAuthor?: UserUpdateOneRequiredWithoutAnotherPostsNestedInput;
}

@InputType()
export class UserCountAggregateInputType {
  @Field(() => Boolean, { nullable: true })
  id?: boolean;
  @Field(() => Boolean, { nullable: true })
  createdAt?: boolean;
  @Field(() => Boolean, { nullable: true })
  updatedAt?: boolean;
  @Field(() => Boolean, { nullable: true })
  email?: boolean;
  @Field(() => Boolean, { nullable: true })
  name?: boolean;
  @Field(() => Boolean, { nullable: true })
  role?: boolean;
  @Field(() => Boolean, { nullable: true })
  parentId?: boolean;
  @Field(() => Boolean, { nullable: true })
  mappedField?: boolean;
}

@InputType()
export class UserAvgAggregateInputType {
  @Field(() => Boolean, { nullable: true })
  id?: boolean;
  @Field(() => Boolean, { nullable: true })
  createdAt?: boolean;
  @Field(() => Boolean, { nullable: true })
  updatedAt?: boolean;
  @Field(() => Boolean, { nullable: true })
  email?: boolean;
  @Field(() => Boolean, { nullable: true })
  name?: boolean;
  @Field(() => Boolean, { nullable: true })
  role?: boolean;
  @Field(() => Boolean, { nullable: true })
  parentId?: boolean;
  @Field(() => Boolean, { nullable: true })
  mappedField?: boolean;
}

@InputType()
export class UserSumAggregateInputType {
  @Field(() => Boolean, { nullable: true })
  id?: boolean;
  @Field(() => Boolean, { nullable: true })
  createdAt?: boolean;
  @Field(() => Boolean, { nullable: true })
  updatedAt?: boolean;
  @Field(() => Boolean, { nullable: true })
  email?: boolean;
  @Field(() => Boolean, { nullable: true })
  name?: boolean;
  @Field(() => Boolean, { nullable: true })
  role?: boolean;
  @Field(() => Boolean, { nullable: true })
  parentId?: boolean;
  @Field(() => Boolean, { nullable: true })
  mappedField?: boolean;
}

@InputType()
export class UserMinAggregateInputType {
  @Field(() => Boolean, { nullable: true })
  id?: boolean;
  @Field(() => Boolean, { nullable: true })
  createdAt?: boolean;
  @Field(() => Boolean, { nullable: true })
  updatedAt?: boolean;
  @Field(() => Boolean, { nullable: true })
  email?: boolean;
  @Field(() => Boolean, { nullable: true })
  name?: boolean;
  @Field(() => Boolean, { nullable: true })
  role?: boolean;
  @Field(() => Boolean, { nullable: true })
  parentId?: boolean;
  @Field(() => Boolean, { nullable: true })
  mappedField?: boolean;
}

@InputType()
export class UserMaxAggregateInputType {
  @Field(() => Boolean, { nullable: true })
  id?: boolean;
  @Field(() => Boolean, { nullable: true })
  createdAt?: boolean;
  @Field(() => Boolean, { nullable: true })
  updatedAt?: boolean;
  @Field(() => Boolean, { nullable: true })
  email?: boolean;
  @Field(() => Boolean, { nullable: true })
  name?: boolean;
  @Field(() => Boolean, { nullable: true })
  role?: boolean;
  @Field(() => Boolean, { nullable: true })
  parentId?: boolean;
  @Field(() => Boolean, { nullable: true })
  mappedField?: boolean;
}

@InputType()
export class ProfileCountAggregateInputType {
  @Field(() => Boolean, { nullable: true })
  id?: boolean;
  @Field(() => Boolean, { nullable: true })
  createdAt?: boolean;
  @Field(() => Boolean, { nullable: true })
  updatedAt?: boolean;
  @Field(() => Boolean, { nullable: true })
  bio?: boolean;
  @Field(() => Boolean, { nullable: true })
  userId?: boolean;
}

@InputType()
export class ProfileAvgAggregateInputType {
  @Field(() => Boolean, { nullable: true })
  id?: boolean;
  @Field(() => Boolean, { nullable: true })
  createdAt?: boolean;
  @Field(() => Boolean, { nullable: true })
  updatedAt?: boolean;
  @Field(() => Boolean, { nullable: true })
  bio?: boolean;
  @Field(() => Boolean, { nullable: true })
  userId?: boolean;
}

@InputType()
export class ProfileSumAggregateInputType {
  @Field(() => Boolean, { nullable: true })
  id?: boolean;
  @Field(() => Boolean, { nullable: true })
  createdAt?: boolean;
  @Field(() => Boolean, { nullable: true })
  updatedAt?: boolean;
  @Field(() => Boolean, { nullable: true })
  bio?: boolean;
  @Field(() => Boolean, { nullable: true })
  userId?: boolean;
}

@InputType()
export class ProfileMinAggregateInputType {
  @Field(() => Boolean, { nullable: true })
  id?: boolean;
  @Field(() => Boolean, { nullable: true })
  createdAt?: boolean;
  @Field(() => Boolean, { nullable: true })
  updatedAt?: boolean;
  @Field(() => Boolean, { nullable: true })
  bio?: boolean;
  @Field(() => Boolean, { nullable: true })
  userId?: boolean;
}

@InputType()
export class ProfileMaxAggregateInputType {
  @Field(() => Boolean, { nullable: true })
  id?: boolean;
  @Field(() => Boolean, { nullable: true })
  createdAt?: boolean;
  @Field(() => Boolean, { nullable: true })
  updatedAt?: boolean;
  @Field(() => Boolean, { nullable: true })
  bio?: boolean;
  @Field(() => Boolean, { nullable: true })
  userId?: boolean;
}

@InputType()
export class PostCountAggregateInputType {
  @Field(() => Boolean, { nullable: true })
  id?: boolean;
  @Field(() => Boolean, { nullable: true })
  createdAt?: boolean;
  @Field(() => Boolean, { nullable: true })
  updatedAt?: boolean;
  @Field(() => Boolean, { nullable: true })
  title?: boolean;
  @Field(() => Boolean, { nullable: true })
  content?: boolean;
  @Field(() => Boolean, { nullable: true })
  published?: boolean;
  @Field(() => Boolean, { nullable: true })
  authorId?: boolean;
  @Field(() => Boolean, { nullable: true })
  anotherAuthorId?: boolean;
  @Field(() => Boolean, { nullable: true })
  postKind?: boolean;
}

@InputType()
export class PostAvgAggregateInputType {
  @Field(() => Boolean, { nullable: true })
  id?: boolean;
  @Field(() => Boolean, { nullable: true })
  createdAt?: boolean;
  @Field(() => Boolean, { nullable: true })
  updatedAt?: boolean;
  @Field(() => Boolean, { nullable: true })
  title?: boolean;
  @Field(() => Boolean, { nullable: true })
  content?: boolean;
  @Field(() => Boolean, { nullable: true })
  published?: boolean;
  @Field(() => Boolean, { nullable: true })
  authorId?: boolean;
  @Field(() => Boolean, { nullable: true })
  anotherAuthorId?: boolean;
  @Field(() => Boolean, { nullable: true })
  postKind?: boolean;
}

@InputType()
export class PostSumAggregateInputType {
  @Field(() => Boolean, { nullable: true })
  id?: boolean;
  @Field(() => Boolean, { nullable: true })
  createdAt?: boolean;
  @Field(() => Boolean, { nullable: true })
  updatedAt?: boolean;
  @Field(() => Boolean, { nullable: true })
  title?: boolean;
  @Field(() => Boolean, { nullable: true })
  content?: boolean;
  @Field(() => Boolean, { nullable: true })
  published?: boolean;
  @Field(() => Boolean, { nullable: true })
  authorId?: boolean;
  @Field(() => Boolean, { nullable: true })
  anotherAuthorId?: boolean;
  @Field(() => Boolean, { nullable: true })
  postKind?: boolean;
}

@InputType()
export class PostMinAggregateInputType {
  @Field(() => Boolean, { nullable: true })
  id?: boolean;
  @Field(() => Boolean, { nullable: true })
  createdAt?: boolean;
  @Field(() => Boolean, { nullable: true })
  updatedAt?: boolean;
  @Field(() => Boolean, { nullable: true })
  title?: boolean;
  @Field(() => Boolean, { nullable: true })
  content?: boolean;
  @Field(() => Boolean, { nullable: true })
  published?: boolean;
  @Field(() => Boolean, { nullable: true })
  authorId?: boolean;
  @Field(() => Boolean, { nullable: true })
  anotherAuthorId?: boolean;
  @Field(() => Boolean, { nullable: true })
  postKind?: boolean;
}

@InputType()
export class PostMaxAggregateInputType {
  @Field(() => Boolean, { nullable: true })
  id?: boolean;
  @Field(() => Boolean, { nullable: true })
  createdAt?: boolean;
  @Field(() => Boolean, { nullable: true })
  updatedAt?: boolean;
  @Field(() => Boolean, { nullable: true })
  title?: boolean;
  @Field(() => Boolean, { nullable: true })
  content?: boolean;
  @Field(() => Boolean, { nullable: true })
  published?: boolean;
  @Field(() => Boolean, { nullable: true })
  authorId?: boolean;
  @Field(() => Boolean, { nullable: true })
  anotherAuthorId?: boolean;
  @Field(() => Boolean, { nullable: true })
  postKind?: boolean;
}

@InputType()
export class TagCountAggregateInputType {
  @Field(() => Boolean, { nullable: true })
  key?: boolean;
}

@InputType()
export class TagAvgAggregateInputType {
  @Field(() => Boolean, { nullable: true })
  key?: boolean;
}

@InputType()
export class TagSumAggregateInputType {
  @Field(() => Boolean, { nullable: true })
  key?: boolean;
}

@InputType()
export class TagMinAggregateInputType {
  @Field(() => Boolean, { nullable: true })
  key?: boolean;
}

@InputType()
export class TagMaxAggregateInputType {
  @Field(() => Boolean, { nullable: true })
  key?: boolean;
}

@InputType()
export class CategoryCountAggregateInputType {
  @Field(() => Boolean, { nullable: true })
  id?: boolean;
  @Field(() => Boolean, { nullable: true })
  createdAt?: boolean;
  @Field(() => Boolean, { nullable: true })
  updatedAt?: boolean;
  @Field(() => Boolean, { nullable: true })
  name?: boolean;
}

@InputType()
export class CategoryAvgAggregateInputType {
  @Field(() => Boolean, { nullable: true })
  id?: boolean;
  @Field(() => Boolean, { nullable: true })
  createdAt?: boolean;
  @Field(() => Boolean, { nullable: true })
  updatedAt?: boolean;
  @Field(() => Boolean, { nullable: true })
  name?: boolean;
}

@InputType()
export class CategorySumAggregateInputType {
  @Field(() => Boolean, { nullable: true })
  id?: boolean;
  @Field(() => Boolean, { nullable: true })
  createdAt?: boolean;
  @Field(() => Boolean, { nullable: true })
  updatedAt?: boolean;
  @Field(() => Boolean, { nullable: true })
  name?: boolean;
}

@InputType()
export class CategoryMinAggregateInputType {
  @Field(() => Boolean, { nullable: true })
  id?: boolean;
  @Field(() => Boolean, { nullable: true })
  createdAt?: boolean;
  @Field(() => Boolean, { nullable: true })
  updatedAt?: boolean;
  @Field(() => Boolean, { nullable: true })
  name?: boolean;
}

@InputType()
export class CategoryMaxAggregateInputType {
  @Field(() => Boolean, { nullable: true })
  id?: boolean;
  @Field(() => Boolean, { nullable: true })
  createdAt?: boolean;
  @Field(() => Boolean, { nullable: true })
  updatedAt?: boolean;
  @Field(() => Boolean, { nullable: true })
  name?: boolean;
}

@InputType()
export class CategoryMetadataCountAggregateInputType {
  @Field(() => Boolean, { nullable: true })
  id?: boolean;
  @Field(() => Boolean, { nullable: true })
  createdAt?: boolean;
  @Field(() => Boolean, { nullable: true })
  updatedAt?: boolean;
  @Field(() => Boolean, { nullable: true })
  categoryId?: boolean;
  @Field(() => Boolean, { nullable: true })
  metadata?: boolean;
}

@InputType()
export class CategoryMetadataAvgAggregateInputType {
  @Field(() => Boolean, { nullable: true })
  id?: boolean;
  @Field(() => Boolean, { nullable: true })
  createdAt?: boolean;
  @Field(() => Boolean, { nullable: true })
  updatedAt?: boolean;
  @Field(() => Boolean, { nullable: true })
  categoryId?: boolean;
  @Field(() => Boolean, { nullable: true })
  metadata?: boolean;
}

@InputType()
export class CategoryMetadataSumAggregateInputType {
  @Field(() => Boolean, { nullable: true })
  id?: boolean;
  @Field(() => Boolean, { nullable: true })
  createdAt?: boolean;
  @Field(() => Boolean, { nullable: true })
  updatedAt?: boolean;
  @Field(() => Boolean, { nullable: true })
  categoryId?: boolean;
  @Field(() => Boolean, { nullable: true })
  metadata?: boolean;
}

@InputType()
export class CategoryMetadataMinAggregateInputType {
  @Field(() => Boolean, { nullable: true })
  id?: boolean;
  @Field(() => Boolean, { nullable: true })
  createdAt?: boolean;
  @Field(() => Boolean, { nullable: true })
  updatedAt?: boolean;
  @Field(() => Boolean, { nullable: true })
  categoryId?: boolean;
  @Field(() => Boolean, { nullable: true })
  metadata?: boolean;
}

@InputType()
export class CategoryMetadataMaxAggregateInputType {
  @Field(() => Boolean, { nullable: true })
  id?: boolean;
  @Field(() => Boolean, { nullable: true })
  createdAt?: boolean;
  @Field(() => Boolean, { nullable: true })
  updatedAt?: boolean;
  @Field(() => Boolean, { nullable: true })
  categoryId?: boolean;
  @Field(() => Boolean, { nullable: true })
  metadata?: boolean;
}

@InputType()
export class MiscModelCountAggregateInputType {
  @Field(() => Boolean, { nullable: true })
  id?: boolean;
  @Field(() => Boolean, { nullable: true })
  createdAt?: boolean;
  @Field(() => Boolean, { nullable: true })
  updatedAt?: boolean;
  @Field(() => Boolean, { nullable: true })
  name?: boolean;
  @Field(() => Boolean, { nullable: true })
  jsonField?: boolean;
  @Field(() => Boolean, { nullable: true })
  jsonList?: boolean;
  @Field(() => Boolean, { nullable: true })
  stringList?: boolean;
  @Field(() => Boolean, { nullable: true })
  decimalField?: boolean;
  @Field(() => Boolean, { nullable: true })
  decimalList?: boolean;
  @Field(() => Boolean, { nullable: true })
  floatField?: boolean;
  @Field(() => Boolean, { nullable: true })
  bytesField?: boolean;
  @Field(() => Boolean, { nullable: true })
  bytesList?: boolean;
  @Field(() => Boolean, { nullable: true })
  bigIntField?: boolean;
  @Field(() => Boolean, { nullable: true })
  bigIntList?: boolean;
  @Field(() => Boolean, { nullable: true })
  dateTimeField?: boolean;
  @Field(() => Boolean, { nullable: true })
  dateTimeList?: boolean;
}

@InputType()
export class MiscModelAvgAggregateInputType {
  @Field(() => Boolean, { nullable: true })
  id?: boolean;
  @Field(() => Boolean, { nullable: true })
  createdAt?: boolean;
  @Field(() => Boolean, { nullable: true })
  updatedAt?: boolean;
  @Field(() => Boolean, { nullable: true })
  name?: boolean;
  @Field(() => Boolean, { nullable: true })
  jsonField?: boolean;
  @Field(() => Boolean, { nullable: true })
  jsonList?: boolean;
  @Field(() => Boolean, { nullable: true })
  stringList?: boolean;
  @Field(() => Boolean, { nullable: true })
  decimalField?: boolean;
  @Field(() => Boolean, { nullable: true })
  decimalList?: boolean;
  @Field(() => Boolean, { nullable: true })
  floatField?: boolean;
  @Field(() => Boolean, { nullable: true })
  bytesField?: boolean;
  @Field(() => Boolean, { nullable: true })
  bytesList?: boolean;
  @Field(() => Boolean, { nullable: true })
  bigIntField?: boolean;
  @Field(() => Boolean, { nullable: true })
  bigIntList?: boolean;
  @Field(() => Boolean, { nullable: true })
  dateTimeField?: boolean;
  @Field(() => Boolean, { nullable: true })
  dateTimeList?: boolean;
}

@InputType()
export class MiscModelSumAggregateInputType {
  @Field(() => Boolean, { nullable: true })
  id?: boolean;
  @Field(() => Boolean, { nullable: true })
  createdAt?: boolean;
  @Field(() => Boolean, { nullable: true })
  updatedAt?: boolean;
  @Field(() => Boolean, { nullable: true })
  name?: boolean;
  @Field(() => Boolean, { nullable: true })
  jsonField?: boolean;
  @Field(() => Boolean, { nullable: true })
  jsonList?: boolean;
  @Field(() => Boolean, { nullable: true })
  stringList?: boolean;
  @Field(() => Boolean, { nullable: true })
  decimalField?: boolean;
  @Field(() => Boolean, { nullable: true })
  decimalList?: boolean;
  @Field(() => Boolean, { nullable: true })
  floatField?: boolean;
  @Field(() => Boolean, { nullable: true })
  bytesField?: boolean;
  @Field(() => Boolean, { nullable: true })
  bytesList?: boolean;
  @Field(() => Boolean, { nullable: true })
  bigIntField?: boolean;
  @Field(() => Boolean, { nullable: true })
  bigIntList?: boolean;
  @Field(() => Boolean, { nullable: true })
  dateTimeField?: boolean;
  @Field(() => Boolean, { nullable: true })
  dateTimeList?: boolean;
}

@InputType()
export class MiscModelMinAggregateInputType {
  @Field(() => Boolean, { nullable: true })
  id?: boolean;
  @Field(() => Boolean, { nullable: true })
  createdAt?: boolean;
  @Field(() => Boolean, { nullable: true })
  updatedAt?: boolean;
  @Field(() => Boolean, { nullable: true })
  name?: boolean;
  @Field(() => Boolean, { nullable: true })
  jsonField?: boolean;
  @Field(() => Boolean, { nullable: true })
  jsonList?: boolean;
  @Field(() => Boolean, { nullable: true })
  stringList?: boolean;
  @Field(() => Boolean, { nullable: true })
  decimalField?: boolean;
  @Field(() => Boolean, { nullable: true })
  decimalList?: boolean;
  @Field(() => Boolean, { nullable: true })
  floatField?: boolean;
  @Field(() => Boolean, { nullable: true })
  bytesField?: boolean;
  @Field(() => Boolean, { nullable: true })
  bytesList?: boolean;
  @Field(() => Boolean, { nullable: true })
  bigIntField?: boolean;
  @Field(() => Boolean, { nullable: true })
  bigIntList?: boolean;
  @Field(() => Boolean, { nullable: true })
  dateTimeField?: boolean;
  @Field(() => Boolean, { nullable: true })
  dateTimeList?: boolean;
}

@InputType()
export class MiscModelMaxAggregateInputType {
  @Field(() => Boolean, { nullable: true })
  id?: boolean;
  @Field(() => Boolean, { nullable: true })
  createdAt?: boolean;
  @Field(() => Boolean, { nullable: true })
  updatedAt?: boolean;
  @Field(() => Boolean, { nullable: true })
  name?: boolean;
  @Field(() => Boolean, { nullable: true })
  jsonField?: boolean;
  @Field(() => Boolean, { nullable: true })
  jsonList?: boolean;
  @Field(() => Boolean, { nullable: true })
  stringList?: boolean;
  @Field(() => Boolean, { nullable: true })
  decimalField?: boolean;
  @Field(() => Boolean, { nullable: true })
  decimalList?: boolean;
  @Field(() => Boolean, { nullable: true })
  floatField?: boolean;
  @Field(() => Boolean, { nullable: true })
  bytesField?: boolean;
  @Field(() => Boolean, { nullable: true })
  bytesList?: boolean;
  @Field(() => Boolean, { nullable: true })
  bigIntField?: boolean;
  @Field(() => Boolean, { nullable: true })
  bigIntList?: boolean;
  @Field(() => Boolean, { nullable: true })
  dateTimeField?: boolean;
  @Field(() => Boolean, { nullable: true })
  dateTimeList?: boolean;
}

@InputType()
export class HiddenModelCountAggregateInputType {
  @Field(() => Boolean, { nullable: true })
  id?: boolean;
  @Field(() => Boolean, { nullable: true })
  createdAt?: boolean;
  @Field(() => Boolean, { nullable: true })
  updatedAt?: boolean;
  @Field(() => Boolean, { nullable: true })
  data?: boolean;
}

@InputType()
export class HiddenModelAvgAggregateInputType {
  @Field(() => Boolean, { nullable: true })
  id?: boolean;
  @Field(() => Boolean, { nullable: true })
  createdAt?: boolean;
  @Field(() => Boolean, { nullable: true })
  updatedAt?: boolean;
  @Field(() => Boolean, { nullable: true })
  data?: boolean;
}

@InputType()
export class HiddenModelSumAggregateInputType {
  @Field(() => Boolean, { nullable: true })
  id?: boolean;
  @Field(() => Boolean, { nullable: true })
  createdAt?: boolean;
  @Field(() => Boolean, { nullable: true })
  updatedAt?: boolean;
  @Field(() => Boolean, { nullable: true })
  data?: boolean;
}

@InputType()
export class HiddenModelMinAggregateInputType {
  @Field(() => Boolean, { nullable: true })
  id?: boolean;
  @Field(() => Boolean, { nullable: true })
  createdAt?: boolean;
  @Field(() => Boolean, { nullable: true })
  updatedAt?: boolean;
  @Field(() => Boolean, { nullable: true })
  data?: boolean;
}

@InputType()
export class HiddenModelMaxAggregateInputType {
  @Field(() => Boolean, { nullable: true })
  id?: boolean;
  @Field(() => Boolean, { nullable: true })
  createdAt?: boolean;
  @Field(() => Boolean, { nullable: true })
  updatedAt?: boolean;
  @Field(() => Boolean, { nullable: true })
  data?: boolean;
}

@ArgsType()
export class UserAggregateArgs {
  @Field(() => UserWhereInput, { nullable: true })
  where?: UserWhereInput;
  @Field(() => [UserOrderByWithRelationInput], { nullable: true })
  orderBy?: UserOrderByWithRelationInput[];
  @Field(() => UserWhereUniqueInput, { nullable: true })
  cursor?: UserWhereUniqueInput;
  @Field(() => Int, { nullable: false })
  take: number;
  @Field(() => Int, { nullable: false })
  skip: number;
  @Field(() => UserCountAggregateInputType, { nullable: true })
  _count?: UserCountAggregateInputType;
  @Field(() => UserAvgAggregateInputType, { nullable: true })
  _avg?: UserAvgAggregateInputType;
  @Field(() => UserSumAggregateInputType, { nullable: true })
  _sum?: UserSumAggregateInputType;
  @Field(() => UserMinAggregateInputType, { nullable: true })
  _min?: UserMinAggregateInputType;
  @Field(() => UserMaxAggregateInputType, { nullable: true })
  _max?: UserMaxAggregateInputType;
}

@ArgsType()
export class UserCreateManyArgs {
  @Field(() => [UserCreateManyInput], { nullable: false })
  data: UserCreateManyInput[];
  @Field(() => Boolean, { nullable: true })
  skipDuplicates?: boolean;
}

@ArgsType()
export class UserDeleteManyArgs {
  @Field(() => UserWhereInput, { nullable: true })
  where?: UserWhereInput;
}

@ArgsType()
export class UserFindFirstArgs {
  @Field(() => UserWhereInput, { nullable: true })
  where?: UserWhereInput;
  @Field(() => [UserOrderByWithRelationInput], { nullable: true })
  orderBy?: UserOrderByWithRelationInput[];
  @Field(() => UserWhereUniqueInput, { nullable: true })
  cursor?: UserWhereUniqueInput;
  @Field(() => Int, { nullable: false })
  take: number;
  @Field(() => Int, { nullable: false })
  skip: number;
  @Field(() => [UserScalarFieldEnum], { nullable: true })
  distinct?: UserScalarFieldEnum[];
}

@ArgsType()
export class UserFindManyArgs {
  @Field(() => UserWhereInput, { nullable: true })
  where?: UserWhereInput;
  @Field(() => [UserOrderByWithRelationInput], { nullable: true })
  orderBy?: UserOrderByWithRelationInput[];
  @Field(() => UserWhereUniqueInput, { nullable: true })
  cursor?: UserWhereUniqueInput;
  @Field(() => Int, { nullable: false })
  take: number;
  @Field(() => Int, { nullable: false })
  skip: number;
  @Field(() => [UserScalarFieldEnum], { nullable: true })
  distinct?: UserScalarFieldEnum[];
}

@ArgsType()
export class UserFindUniqueArgs {
  @Field(() => UserWhereUniqueInput, { nullable: false })
  where: UserWhereUniqueInput;
}

@ArgsType()
export class UserGroupByArgs {
  @Field(() => UserWhereInput, { nullable: true })
  where?: UserWhereInput;
  @Field(() => [UserOrderByWithAggregationInput], { nullable: true })
  orderBy?: UserOrderByWithAggregationInput[];
  @Field(() => [UserScalarFieldEnum], { nullable: false })
  by: UserScalarFieldEnum[];
  @Field(() => UserScalarWhereWithAggregatesInput, { nullable: true })
  having?: UserScalarWhereWithAggregatesInput;
  @Field(() => Int, { nullable: false })
  take: number;
  @Field(() => Int, { nullable: false })
  skip: number;
}

@ArgsType()
export class UserUpdateManyArgs {
  @Field(() => UserUpdateManyMutationInput, { nullable: false })
  data: UserUpdateManyMutationInput;
  @Field(() => UserWhereInput, { nullable: true })
  where?: UserWhereInput;
}

@ArgsType()
export class UserCountArgs {
  @Field(() => UserWhereInput, { nullable: true })
  where?: UserWhereInput;
  @Field(() => [UserOrderByWithRelationInput], { nullable: true })
  orderBy?: UserOrderByWithRelationInput[];
  @Field(() => UserWhereUniqueInput, { nullable: true })
  cursor?: UserWhereUniqueInput;
  @Field(() => Int, { nullable: false })
  take: number;
  @Field(() => Int, { nullable: false })
  skip: number;
  @Field(() => [UserScalarFieldEnum], { nullable: true })
  distinct?: UserScalarFieldEnum[];
}

@ArgsType()
export class ProfileAggregateArgs {
  @Field(() => ProfileWhereInput, { nullable: true })
  where?: ProfileWhereInput;
  @Field(() => [ProfileOrderByWithRelationInput], { nullable: true })
  orderBy?: ProfileOrderByWithRelationInput[];
  @Field(() => ProfileWhereUniqueInput, { nullable: true })
  cursor?: ProfileWhereUniqueInput;
  @Field(() => Int, { nullable: false })
  take: number;
  @Field(() => Int, { nullable: false })
  skip: number;
  @Field(() => ProfileCountAggregateInputType, { nullable: true })
  _count?: ProfileCountAggregateInputType;
  @Field(() => ProfileAvgAggregateInputType, { nullable: true })
  _avg?: ProfileAvgAggregateInputType;
  @Field(() => ProfileSumAggregateInputType, { nullable: true })
  _sum?: ProfileSumAggregateInputType;
  @Field(() => ProfileMinAggregateInputType, { nullable: true })
  _min?: ProfileMinAggregateInputType;
  @Field(() => ProfileMaxAggregateInputType, { nullable: true })
  _max?: ProfileMaxAggregateInputType;
}

@ArgsType()
export class ProfileCreateManyArgs {
  @Field(() => [ProfileCreateManyInput], { nullable: false })
  data: ProfileCreateManyInput[];
  @Field(() => Boolean, { nullable: true })
  skipDuplicates?: boolean;
}

@ArgsType()
export class ProfileDeleteManyArgs {
  @Field(() => ProfileWhereInput, { nullable: true })
  where?: ProfileWhereInput;
}

@ArgsType()
export class ProfileFindFirstArgs {
  @Field(() => ProfileWhereInput, { nullable: true })
  where?: ProfileWhereInput;
  @Field(() => [ProfileOrderByWithRelationInput], { nullable: true })
  orderBy?: ProfileOrderByWithRelationInput[];
  @Field(() => ProfileWhereUniqueInput, { nullable: true })
  cursor?: ProfileWhereUniqueInput;
  @Field(() => Int, { nullable: false })
  take: number;
  @Field(() => Int, { nullable: false })
  skip: number;
  @Field(() => [ProfileScalarFieldEnum], { nullable: true })
  distinct?: ProfileScalarFieldEnum[];
}

@ArgsType()
export class ProfileFindManyArgs {
  @Field(() => ProfileWhereInput, { nullable: true })
  where?: ProfileWhereInput;
  @Field(() => [ProfileOrderByWithRelationInput], { nullable: true })
  orderBy?: ProfileOrderByWithRelationInput[];
  @Field(() => ProfileWhereUniqueInput, { nullable: true })
  cursor?: ProfileWhereUniqueInput;
  @Field(() => Int, { nullable: false })
  take: number;
  @Field(() => Int, { nullable: false })
  skip: number;
  @Field(() => [ProfileScalarFieldEnum], { nullable: true })
  distinct?: ProfileScalarFieldEnum[];
}

@ArgsType()
export class ProfileFindUniqueArgs {
  @Field(() => ProfileWhereUniqueInput, { nullable: false })
  where: ProfileWhereUniqueInput;
}

@ArgsType()
export class ProfileGroupByArgs {
  @Field(() => ProfileWhereInput, { nullable: true })
  where?: ProfileWhereInput;
  @Field(() => [ProfileOrderByWithAggregationInput], { nullable: true })
  orderBy?: ProfileOrderByWithAggregationInput[];
  @Field(() => [ProfileScalarFieldEnum], { nullable: false })
  by: ProfileScalarFieldEnum[];
  @Field(() => ProfileScalarWhereWithAggregatesInput, { nullable: true })
  having?: ProfileScalarWhereWithAggregatesInput;
  @Field(() => Int, { nullable: false })
  take: number;
  @Field(() => Int, { nullable: false })
  skip: number;
}

@ArgsType()
export class ProfileUpdateManyArgs {
  @Field(() => ProfileUpdateManyMutationInput, { nullable: false })
  data: ProfileUpdateManyMutationInput;
  @Field(() => ProfileWhereInput, { nullable: true })
  where?: ProfileWhereInput;
}

@ArgsType()
export class ProfileCountArgs {
  @Field(() => ProfileWhereInput, { nullable: true })
  where?: ProfileWhereInput;
  @Field(() => [ProfileOrderByWithRelationInput], { nullable: true })
  orderBy?: ProfileOrderByWithRelationInput[];
  @Field(() => ProfileWhereUniqueInput, { nullable: true })
  cursor?: ProfileWhereUniqueInput;
  @Field(() => Int, { nullable: false })
  take: number;
  @Field(() => Int, { nullable: false })
  skip: number;
  @Field(() => [ProfileScalarFieldEnum], { nullable: true })
  distinct?: ProfileScalarFieldEnum[];
}

@ArgsType()
export class PostAggregateArgs {
  @Field(() => PostWhereInput, { nullable: true })
  where?: PostWhereInput;
  @Field(() => [PostOrderByWithRelationInput], { nullable: true })
  orderBy?: PostOrderByWithRelationInput[];
  @Field(() => PostWhereUniqueInput, { nullable: true })
  cursor?: PostWhereUniqueInput;
  @Field(() => Int, { nullable: false })
  take: number;
  @Field(() => Int, { nullable: false })
  skip: number;
  @Field(() => PostCountAggregateInputType, { nullable: true })
  _count?: PostCountAggregateInputType;
  @Field(() => PostAvgAggregateInputType, { nullable: true })
  _avg?: PostAvgAggregateInputType;
  @Field(() => PostSumAggregateInputType, { nullable: true })
  _sum?: PostSumAggregateInputType;
  @Field(() => PostMinAggregateInputType, { nullable: true })
  _min?: PostMinAggregateInputType;
  @Field(() => PostMaxAggregateInputType, { nullable: true })
  _max?: PostMaxAggregateInputType;
}

@ArgsType()
export class PostCreateManyArgs {
  @Field(() => [PostCreateManyInput], { nullable: false })
  data: PostCreateManyInput[];
  @Field(() => Boolean, { nullable: true })
  skipDuplicates?: boolean;
}

@ArgsType()
export class PostDeleteManyArgs {
  @Field(() => PostWhereInput, { nullable: true })
  where?: PostWhereInput;
}

@ArgsType()
export class PostFindFirstArgs {
  @Field(() => PostWhereInput, { nullable: true })
  where?: PostWhereInput;
  @Field(() => [PostOrderByWithRelationInput], { nullable: true })
  orderBy?: PostOrderByWithRelationInput[];
  @Field(() => PostWhereUniqueInput, { nullable: true })
  cursor?: PostWhereUniqueInput;
  @Field(() => Int, { nullable: false })
  take: number;
  @Field(() => Int, { nullable: false })
  skip: number;
  @Field(() => [PostScalarFieldEnum], { nullable: true })
  distinct?: PostScalarFieldEnum[];
}

@ArgsType()
export class PostFindManyArgs {
  @Field(() => PostWhereInput, { nullable: true })
  where?: PostWhereInput;
  @Field(() => [PostOrderByWithRelationInput], { nullable: true })
  orderBy?: PostOrderByWithRelationInput[];
  @Field(() => PostWhereUniqueInput, { nullable: true })
  cursor?: PostWhereUniqueInput;
  @Field(() => Int, { nullable: false })
  take: number;
  @Field(() => Int, { nullable: false })
  skip: number;
  @Field(() => [PostScalarFieldEnum], { nullable: true })
  distinct?: PostScalarFieldEnum[];
}

@ArgsType()
export class PostFindUniqueArgs {
  @Field(() => PostWhereUniqueInput, { nullable: false })
  where: PostWhereUniqueInput;
}

@ArgsType()
export class PostGroupByArgs {
  @Field(() => PostWhereInput, { nullable: true })
  where?: PostWhereInput;
  @Field(() => [PostOrderByWithAggregationInput], { nullable: true })
  orderBy?: PostOrderByWithAggregationInput[];
  @Field(() => [PostScalarFieldEnum], { nullable: false })
  by: PostScalarFieldEnum[];
  @Field(() => PostScalarWhereWithAggregatesInput, { nullable: true })
  having?: PostScalarWhereWithAggregatesInput;
  @Field(() => Int, { nullable: false })
  take: number;
  @Field(() => Int, { nullable: false })
  skip: number;
}

@ArgsType()
export class PostUpdateManyArgs {
  @Field(() => PostUpdateManyMutationInput, { nullable: false })
  data: PostUpdateManyMutationInput;
  @Field(() => PostWhereInput, { nullable: true })
  where?: PostWhereInput;
}

@ArgsType()
export class PostCountArgs {
  @Field(() => PostWhereInput, { nullable: true })
  where?: PostWhereInput;
  @Field(() => [PostOrderByWithRelationInput], { nullable: true })
  orderBy?: PostOrderByWithRelationInput[];
  @Field(() => PostWhereUniqueInput, { nullable: true })
  cursor?: PostWhereUniqueInput;
  @Field(() => Int, { nullable: false })
  take: number;
  @Field(() => Int, { nullable: false })
  skip: number;
  @Field(() => [PostScalarFieldEnum], { nullable: true })
  distinct?: PostScalarFieldEnum[];
}

@ArgsType()
export class TagAggregateArgs {
  @Field(() => TagWhereInput, { nullable: true })
  where?: TagWhereInput;
  @Field(() => [TagOrderByWithRelationInput], { nullable: true })
  orderBy?: TagOrderByWithRelationInput[];
  @Field(() => TagWhereUniqueInput, { nullable: true })
  cursor?: TagWhereUniqueInput;
  @Field(() => Int, { nullable: false })
  take: number;
  @Field(() => Int, { nullable: false })
  skip: number;
  @Field(() => TagCountAggregateInputType, { nullable: true })
  _count?: TagCountAggregateInputType;
  @Field(() => TagAvgAggregateInputType, { nullable: true })
  _avg?: TagAvgAggregateInputType;
  @Field(() => TagSumAggregateInputType, { nullable: true })
  _sum?: TagSumAggregateInputType;
  @Field(() => TagMinAggregateInputType, { nullable: true })
  _min?: TagMinAggregateInputType;
  @Field(() => TagMaxAggregateInputType, { nullable: true })
  _max?: TagMaxAggregateInputType;
}

@ArgsType()
export class TagCreateManyArgs {
  @Field(() => [TagCreateManyInput], { nullable: false })
  data: TagCreateManyInput[];
  @Field(() => Boolean, { nullable: true })
  skipDuplicates?: boolean;
}

@ArgsType()
export class TagDeleteManyArgs {
  @Field(() => TagWhereInput, { nullable: true })
  where?: TagWhereInput;
}

@ArgsType()
export class TagFindFirstArgs {
  @Field(() => TagWhereInput, { nullable: true })
  where?: TagWhereInput;
  @Field(() => [TagOrderByWithRelationInput], { nullable: true })
  orderBy?: TagOrderByWithRelationInput[];
  @Field(() => TagWhereUniqueInput, { nullable: true })
  cursor?: TagWhereUniqueInput;
  @Field(() => Int, { nullable: false })
  take: number;
  @Field(() => Int, { nullable: false })
  skip: number;
  @Field(() => [TagScalarFieldEnum], { nullable: true })
  distinct?: TagScalarFieldEnum[];
}

@ArgsType()
export class TagFindManyArgs {
  @Field(() => TagWhereInput, { nullable: true })
  where?: TagWhereInput;
  @Field(() => [TagOrderByWithRelationInput], { nullable: true })
  orderBy?: TagOrderByWithRelationInput[];
  @Field(() => TagWhereUniqueInput, { nullable: true })
  cursor?: TagWhereUniqueInput;
  @Field(() => Int, { nullable: false })
  take: number;
  @Field(() => Int, { nullable: false })
  skip: number;
  @Field(() => [TagScalarFieldEnum], { nullable: true })
  distinct?: TagScalarFieldEnum[];
}

@ArgsType()
export class TagFindUniqueArgs {
  @Field(() => TagWhereUniqueInput, { nullable: false })
  where: TagWhereUniqueInput;
}

@ArgsType()
export class TagGroupByArgs {
  @Field(() => TagWhereInput, { nullable: true })
  where?: TagWhereInput;
  @Field(() => [TagOrderByWithAggregationInput], { nullable: true })
  orderBy?: TagOrderByWithAggregationInput[];
  @Field(() => [TagScalarFieldEnum], { nullable: false })
  by: TagScalarFieldEnum[];
  @Field(() => TagScalarWhereWithAggregatesInput, { nullable: true })
  having?: TagScalarWhereWithAggregatesInput;
  @Field(() => Int, { nullable: false })
  take: number;
  @Field(() => Int, { nullable: false })
  skip: number;
}

@ArgsType()
export class TagUpdateManyArgs {
  @Field(() => TagUpdateManyMutationInput, { nullable: false })
  data: TagUpdateManyMutationInput;
  @Field(() => TagWhereInput, { nullable: true })
  where?: TagWhereInput;
}

@ArgsType()
export class TagCountArgs {
  @Field(() => TagWhereInput, { nullable: true })
  where?: TagWhereInput;
  @Field(() => [TagOrderByWithRelationInput], { nullable: true })
  orderBy?: TagOrderByWithRelationInput[];
  @Field(() => TagWhereUniqueInput, { nullable: true })
  cursor?: TagWhereUniqueInput;
  @Field(() => Int, { nullable: false })
  take: number;
  @Field(() => Int, { nullable: false })
  skip: number;
  @Field(() => [TagScalarFieldEnum], { nullable: true })
  distinct?: TagScalarFieldEnum[];
}

@ArgsType()
export class CategoryAggregateArgs {
  @Field(() => CategoryWhereInput, { nullable: true })
  where?: CategoryWhereInput;
  @Field(() => [CategoryOrderByWithRelationInput], { nullable: true })
  orderBy?: CategoryOrderByWithRelationInput[];
  @Field(() => CategoryWhereUniqueInput, { nullable: true })
  cursor?: CategoryWhereUniqueInput;
  @Field(() => Int, { nullable: false })
  take: number;
  @Field(() => Int, { nullable: false })
  skip: number;
  @Field(() => CategoryCountAggregateInputType, { nullable: true })
  _count?: CategoryCountAggregateInputType;
  @Field(() => CategoryAvgAggregateInputType, { nullable: true })
  _avg?: CategoryAvgAggregateInputType;
  @Field(() => CategorySumAggregateInputType, { nullable: true })
  _sum?: CategorySumAggregateInputType;
  @Field(() => CategoryMinAggregateInputType, { nullable: true })
  _min?: CategoryMinAggregateInputType;
  @Field(() => CategoryMaxAggregateInputType, { nullable: true })
  _max?: CategoryMaxAggregateInputType;
}

@ArgsType()
export class CategoryCreateManyArgs {
  @Field(() => [CategoryCreateManyInput], { nullable: false })
  data: CategoryCreateManyInput[];
  @Field(() => Boolean, { nullable: true })
  skipDuplicates?: boolean;
}

@ArgsType()
export class CategoryDeleteManyArgs {
  @Field(() => CategoryWhereInput, { nullable: true })
  where?: CategoryWhereInput;
}

@ArgsType()
export class CategoryFindFirstArgs {
  @Field(() => CategoryWhereInput, { nullable: true })
  where?: CategoryWhereInput;
  @Field(() => [CategoryOrderByWithRelationInput], { nullable: true })
  orderBy?: CategoryOrderByWithRelationInput[];
  @Field(() => CategoryWhereUniqueInput, { nullable: true })
  cursor?: CategoryWhereUniqueInput;
  @Field(() => Int, { nullable: false })
  take: number;
  @Field(() => Int, { nullable: false })
  skip: number;
  @Field(() => [CategoryScalarFieldEnum], { nullable: true })
  distinct?: CategoryScalarFieldEnum[];
}

@ArgsType()
export class CategoryFindManyArgs {
  @Field(() => CategoryWhereInput, { nullable: true })
  where?: CategoryWhereInput;
  @Field(() => [CategoryOrderByWithRelationInput], { nullable: true })
  orderBy?: CategoryOrderByWithRelationInput[];
  @Field(() => CategoryWhereUniqueInput, { nullable: true })
  cursor?: CategoryWhereUniqueInput;
  @Field(() => Int, { nullable: false })
  take: number;
  @Field(() => Int, { nullable: false })
  skip: number;
  @Field(() => [CategoryScalarFieldEnum], { nullable: true })
  distinct?: CategoryScalarFieldEnum[];
}

@ArgsType()
export class CategoryFindUniqueArgs {
  @Field(() => CategoryWhereUniqueInput, { nullable: false })
  where: CategoryWhereUniqueInput;
}

@ArgsType()
export class CategoryGroupByArgs {
  @Field(() => CategoryWhereInput, { nullable: true })
  where?: CategoryWhereInput;
  @Field(() => [CategoryOrderByWithAggregationInput], { nullable: true })
  orderBy?: CategoryOrderByWithAggregationInput[];
  @Field(() => [CategoryScalarFieldEnum], { nullable: false })
  by: CategoryScalarFieldEnum[];
  @Field(() => CategoryScalarWhereWithAggregatesInput, { nullable: true })
  having?: CategoryScalarWhereWithAggregatesInput;
  @Field(() => Int, { nullable: false })
  take: number;
  @Field(() => Int, { nullable: false })
  skip: number;
}

@ArgsType()
export class CategoryUpdateManyArgs {
  @Field(() => CategoryUpdateManyMutationInput, { nullable: false })
  data: CategoryUpdateManyMutationInput;
  @Field(() => CategoryWhereInput, { nullable: true })
  where?: CategoryWhereInput;
}

@ArgsType()
export class CategoryCountArgs {
  @Field(() => CategoryWhereInput, { nullable: true })
  where?: CategoryWhereInput;
  @Field(() => [CategoryOrderByWithRelationInput], { nullable: true })
  orderBy?: CategoryOrderByWithRelationInput[];
  @Field(() => CategoryWhereUniqueInput, { nullable: true })
  cursor?: CategoryWhereUniqueInput;
  @Field(() => Int, { nullable: false })
  take: number;
  @Field(() => Int, { nullable: false })
  skip: number;
  @Field(() => [CategoryScalarFieldEnum], { nullable: true })
  distinct?: CategoryScalarFieldEnum[];
}

@ArgsType()
export class CategoryMetadataAggregateArgs {
  @Field(() => CategoryMetadataWhereInput, { nullable: true })
  where?: CategoryMetadataWhereInput;
  @Field(() => [CategoryMetadataOrderByWithRelationInput], { nullable: true })
  orderBy?: CategoryMetadataOrderByWithRelationInput[];
  @Field(() => CategoryMetadataWhereUniqueInput, { nullable: true })
  cursor?: CategoryMetadataWhereUniqueInput;
  @Field(() => Int, { nullable: false })
  take: number;
  @Field(() => Int, { nullable: false })
  skip: number;
  @Field(() => CategoryMetadataCountAggregateInputType, { nullable: true })
  _count?: CategoryMetadataCountAggregateInputType;
  @Field(() => CategoryMetadataAvgAggregateInputType, { nullable: true })
  _avg?: CategoryMetadataAvgAggregateInputType;
  @Field(() => CategoryMetadataSumAggregateInputType, { nullable: true })
  _sum?: CategoryMetadataSumAggregateInputType;
  @Field(() => CategoryMetadataMinAggregateInputType, { nullable: true })
  _min?: CategoryMetadataMinAggregateInputType;
  @Field(() => CategoryMetadataMaxAggregateInputType, { nullable: true })
  _max?: CategoryMetadataMaxAggregateInputType;
}

@ArgsType()
export class CategoryMetadataCreateManyArgs {
  @Field(() => [CategoryMetadataCreateManyInput], { nullable: false })
  data: CategoryMetadataCreateManyInput[];
  @Field(() => Boolean, { nullable: true })
  skipDuplicates?: boolean;
}

@ArgsType()
export class CategoryMetadataDeleteManyArgs {
  @Field(() => CategoryMetadataWhereInput, { nullable: true })
  where?: CategoryMetadataWhereInput;
}

@ArgsType()
export class CategoryMetadataFindFirstArgs {
  @Field(() => CategoryMetadataWhereInput, { nullable: true })
  where?: CategoryMetadataWhereInput;
  @Field(() => [CategoryMetadataOrderByWithRelationInput], { nullable: true })
  orderBy?: CategoryMetadataOrderByWithRelationInput[];
  @Field(() => CategoryMetadataWhereUniqueInput, { nullable: true })
  cursor?: CategoryMetadataWhereUniqueInput;
  @Field(() => Int, { nullable: false })
  take: number;
  @Field(() => Int, { nullable: false })
  skip: number;
  @Field(() => [CategoryMetadataScalarFieldEnum], { nullable: true })
  distinct?: CategoryMetadataScalarFieldEnum[];
}

@ArgsType()
export class CategoryMetadataFindManyArgs {
  @Field(() => CategoryMetadataWhereInput, { nullable: true })
  where?: CategoryMetadataWhereInput;
  @Field(() => [CategoryMetadataOrderByWithRelationInput], { nullable: true })
  orderBy?: CategoryMetadataOrderByWithRelationInput[];
  @Field(() => CategoryMetadataWhereUniqueInput, { nullable: true })
  cursor?: CategoryMetadataWhereUniqueInput;
  @Field(() => Int, { nullable: false })
  take: number;
  @Field(() => Int, { nullable: false })
  skip: number;
  @Field(() => [CategoryMetadataScalarFieldEnum], { nullable: true })
  distinct?: CategoryMetadataScalarFieldEnum[];
}

@ArgsType()
export class CategoryMetadataFindUniqueArgs {
  @Field(() => CategoryMetadataWhereUniqueInput, { nullable: false })
  where: CategoryMetadataWhereUniqueInput;
}

@ArgsType()
export class CategoryMetadataGroupByArgs {
  @Field(() => CategoryMetadataWhereInput, { nullable: true })
  where?: CategoryMetadataWhereInput;
  @Field(() => [CategoryMetadataOrderByWithAggregationInput], {
    nullable: true,
  })
  orderBy?: CategoryMetadataOrderByWithAggregationInput[];
  @Field(() => [CategoryMetadataScalarFieldEnum], { nullable: false })
  by: CategoryMetadataScalarFieldEnum[];
  @Field(() => CategoryMetadataScalarWhereWithAggregatesInput, {
    nullable: true,
  })
  having?: CategoryMetadataScalarWhereWithAggregatesInput;
  @Field(() => Int, { nullable: false })
  take: number;
  @Field(() => Int, { nullable: false })
  skip: number;
}

@ArgsType()
export class CategoryMetadataUpdateManyArgs {
  @Field(() => CategoryMetadataUpdateManyMutationInput, { nullable: false })
  data: CategoryMetadataUpdateManyMutationInput;
  @Field(() => CategoryMetadataWhereInput, { nullable: true })
  where?: CategoryMetadataWhereInput;
}

@ArgsType()
export class CategoryMetadataCountArgs {
  @Field(() => CategoryMetadataWhereInput, { nullable: true })
  where?: CategoryMetadataWhereInput;
  @Field(() => [CategoryMetadataOrderByWithRelationInput], { nullable: true })
  orderBy?: CategoryMetadataOrderByWithRelationInput[];
  @Field(() => CategoryMetadataWhereUniqueInput, { nullable: true })
  cursor?: CategoryMetadataWhereUniqueInput;
  @Field(() => Int, { nullable: false })
  take: number;
  @Field(() => Int, { nullable: false })
  skip: number;
  @Field(() => [CategoryMetadataScalarFieldEnum], { nullable: true })
  distinct?: CategoryMetadataScalarFieldEnum[];
}

@ArgsType()
export class MiscModelAggregateArgs {
  @Field(() => MiscModelWhereInput, { nullable: true })
  where?: MiscModelWhereInput;
  @Field(() => [MiscModelOrderByWithRelationInput], { nullable: true })
  orderBy?: MiscModelOrderByWithRelationInput[];
  @Field(() => MiscModelWhereUniqueInput, { nullable: true })
  cursor?: MiscModelWhereUniqueInput;
  @Field(() => Int, { nullable: false })
  take: number;
  @Field(() => Int, { nullable: false })
  skip: number;
  @Field(() => MiscModelCountAggregateInputType, { nullable: true })
  _count?: MiscModelCountAggregateInputType;
  @Field(() => MiscModelAvgAggregateInputType, { nullable: true })
  _avg?: MiscModelAvgAggregateInputType;
  @Field(() => MiscModelSumAggregateInputType, { nullable: true })
  _sum?: MiscModelSumAggregateInputType;
  @Field(() => MiscModelMinAggregateInputType, { nullable: true })
  _min?: MiscModelMinAggregateInputType;
  @Field(() => MiscModelMaxAggregateInputType, { nullable: true })
  _max?: MiscModelMaxAggregateInputType;
}

@ArgsType()
export class MiscModelCreateManyArgs {
  @Field(() => [MiscModelCreateManyInput], { nullable: false })
  data: MiscModelCreateManyInput[];
  @Field(() => Boolean, { nullable: true })
  skipDuplicates?: boolean;
}

@ArgsType()
export class MiscModelDeleteManyArgs {
  @Field(() => MiscModelWhereInput, { nullable: true })
  where?: MiscModelWhereInput;
}

@ArgsType()
export class MiscModelFindFirstArgs {
  @Field(() => MiscModelWhereInput, { nullable: true })
  where?: MiscModelWhereInput;
  @Field(() => [MiscModelOrderByWithRelationInput], { nullable: true })
  orderBy?: MiscModelOrderByWithRelationInput[];
  @Field(() => MiscModelWhereUniqueInput, { nullable: true })
  cursor?: MiscModelWhereUniqueInput;
  @Field(() => Int, { nullable: false })
  take: number;
  @Field(() => Int, { nullable: false })
  skip: number;
  @Field(() => [MiscModelScalarFieldEnum], { nullable: true })
  distinct?: MiscModelScalarFieldEnum[];
}

@ArgsType()
export class MiscModelFindManyArgs {
  @Field(() => MiscModelWhereInput, { nullable: true })
  where?: MiscModelWhereInput;
  @Field(() => [MiscModelOrderByWithRelationInput], { nullable: true })
  orderBy?: MiscModelOrderByWithRelationInput[];
  @Field(() => MiscModelWhereUniqueInput, { nullable: true })
  cursor?: MiscModelWhereUniqueInput;
  @Field(() => Int, { nullable: false })
  take: number;
  @Field(() => Int, { nullable: false })
  skip: number;
  @Field(() => [MiscModelScalarFieldEnum], { nullable: true })
  distinct?: MiscModelScalarFieldEnum[];
}

@ArgsType()
export class MiscModelFindUniqueArgs {
  @Field(() => MiscModelWhereUniqueInput, { nullable: false })
  where: MiscModelWhereUniqueInput;
}

@ArgsType()
export class MiscModelGroupByArgs {
  @Field(() => MiscModelWhereInput, { nullable: true })
  where?: MiscModelWhereInput;
  @Field(() => [MiscModelOrderByWithAggregationInput], { nullable: true })
  orderBy?: MiscModelOrderByWithAggregationInput[];
  @Field(() => [MiscModelScalarFieldEnum], { nullable: false })
  by: MiscModelScalarFieldEnum[];
  @Field(() => MiscModelScalarWhereWithAggregatesInput, { nullable: true })
  having?: MiscModelScalarWhereWithAggregatesInput;
  @Field(() => Int, { nullable: false })
  take: number;
  @Field(() => Int, { nullable: false })
  skip: number;
}

@ArgsType()
export class MiscModelUpdateManyArgs {
  @Field(() => MiscModelUpdateManyMutationInput, { nullable: false })
  data: MiscModelUpdateManyMutationInput;
  @Field(() => MiscModelWhereInput, { nullable: true })
  where?: MiscModelWhereInput;
}

@ArgsType()
export class MiscModelCountArgs {
  @Field(() => MiscModelWhereInput, { nullable: true })
  where?: MiscModelWhereInput;
  @Field(() => [MiscModelOrderByWithRelationInput], { nullable: true })
  orderBy?: MiscModelOrderByWithRelationInput[];
  @Field(() => MiscModelWhereUniqueInput, { nullable: true })
  cursor?: MiscModelWhereUniqueInput;
  @Field(() => Int, { nullable: false })
  take: number;
  @Field(() => Int, { nullable: false })
  skip: number;
  @Field(() => [MiscModelScalarFieldEnum], { nullable: true })
  distinct?: MiscModelScalarFieldEnum[];
}

@ArgsType()
export class HiddenModelAggregateArgs {
  @Field(() => HiddenModelWhereInput, { nullable: true })
  where?: HiddenModelWhereInput;
  @Field(() => [HiddenModelOrderByWithRelationInput], { nullable: true })
  orderBy?: HiddenModelOrderByWithRelationInput[];
  @Field(() => HiddenModelWhereUniqueInput, { nullable: true })
  cursor?: HiddenModelWhereUniqueInput;
  @Field(() => Int, { nullable: false })
  take: number;
  @Field(() => Int, { nullable: false })
  skip: number;
  @Field(() => HiddenModelCountAggregateInputType, { nullable: true })
  _count?: HiddenModelCountAggregateInputType;
  @Field(() => HiddenModelAvgAggregateInputType, { nullable: true })
  _avg?: HiddenModelAvgAggregateInputType;
  @Field(() => HiddenModelSumAggregateInputType, { nullable: true })
  _sum?: HiddenModelSumAggregateInputType;
  @Field(() => HiddenModelMinAggregateInputType, { nullable: true })
  _min?: HiddenModelMinAggregateInputType;
  @Field(() => HiddenModelMaxAggregateInputType, { nullable: true })
  _max?: HiddenModelMaxAggregateInputType;
}

@ArgsType()
export class HiddenModelCreateManyArgs {
  @Field(() => [HiddenModelCreateManyInput], { nullable: false })
  data: HiddenModelCreateManyInput[];
  @Field(() => Boolean, { nullable: true })
  skipDuplicates?: boolean;
}

@ArgsType()
export class HiddenModelDeleteManyArgs {
  @Field(() => HiddenModelWhereInput, { nullable: true })
  where?: HiddenModelWhereInput;
}

@ArgsType()
export class HiddenModelFindFirstArgs {
  @Field(() => HiddenModelWhereInput, { nullable: true })
  where?: HiddenModelWhereInput;
  @Field(() => [HiddenModelOrderByWithRelationInput], { nullable: true })
  orderBy?: HiddenModelOrderByWithRelationInput[];
  @Field(() => HiddenModelWhereUniqueInput, { nullable: true })
  cursor?: HiddenModelWhereUniqueInput;
  @Field(() => Int, { nullable: false })
  take: number;
  @Field(() => Int, { nullable: false })
  skip: number;
  @Field(() => [HiddenModelScalarFieldEnum], { nullable: true })
  distinct?: HiddenModelScalarFieldEnum[];
}

@ArgsType()
export class HiddenModelFindManyArgs {
  @Field(() => HiddenModelWhereInput, { nullable: true })
  where?: HiddenModelWhereInput;
  @Field(() => [HiddenModelOrderByWithRelationInput], { nullable: true })
  orderBy?: HiddenModelOrderByWithRelationInput[];
  @Field(() => HiddenModelWhereUniqueInput, { nullable: true })
  cursor?: HiddenModelWhereUniqueInput;
  @Field(() => Int, { nullable: false })
  take: number;
  @Field(() => Int, { nullable: false })
  skip: number;
  @Field(() => [HiddenModelScalarFieldEnum], { nullable: true })
  distinct?: HiddenModelScalarFieldEnum[];
}

@ArgsType()
export class HiddenModelFindUniqueArgs {
  @Field(() => HiddenModelWhereUniqueInput, { nullable: false })
  where: HiddenModelWhereUniqueInput;
}

@ArgsType()
export class HiddenModelGroupByArgs {
  @Field(() => HiddenModelWhereInput, { nullable: true })
  where?: HiddenModelWhereInput;
  @Field(() => [HiddenModelOrderByWithAggregationInput], { nullable: true })
  orderBy?: HiddenModelOrderByWithAggregationInput[];
  @Field(() => [HiddenModelScalarFieldEnum], { nullable: false })
  by: HiddenModelScalarFieldEnum[];
  @Field(() => HiddenModelScalarWhereWithAggregatesInput, { nullable: true })
  having?: HiddenModelScalarWhereWithAggregatesInput;
  @Field(() => Int, { nullable: false })
  take: number;
  @Field(() => Int, { nullable: false })
  skip: number;
}

@ArgsType()
export class HiddenModelUpdateManyArgs {
  @Field(() => HiddenModelUpdateManyMutationInput, { nullable: false })
  data: HiddenModelUpdateManyMutationInput;
  @Field(() => HiddenModelWhereInput, { nullable: true })
  where?: HiddenModelWhereInput;
}

@ArgsType()
export class HiddenModelCountArgs {
  @Field(() => HiddenModelWhereInput, { nullable: true })
  where?: HiddenModelWhereInput;
  @Field(() => [HiddenModelOrderByWithRelationInput], { nullable: true })
  orderBy?: HiddenModelOrderByWithRelationInput[];
  @Field(() => HiddenModelWhereUniqueInput, { nullable: true })
  cursor?: HiddenModelWhereUniqueInput;
  @Field(() => Int, { nullable: false })
  take: number;
  @Field(() => Int, { nullable: false })
  skip: number;
  @Field(() => [HiddenModelScalarFieldEnum], { nullable: true })
  distinct?: HiddenModelScalarFieldEnum[];
}
